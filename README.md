# **Gu√≠a de Java para Principiantes**

## **Introducci√≥n**
Bienvenido a la Gu√≠a de Java para Principiantes. Este documento tiene como objetivo proporcionar una introducci√≥n completa y clara a los conceptos fundamentales de Java. A lo largo de esta gu√≠a, exploraremos desde la sintaxis b√°sica hasta temas m√°s avanzados, como el manejo de excepciones y la programaci√≥n orientada a objetos.

---

# üìò E2T_Java
# √çndice:

- [CAP√çTULO 1: BREVE HISTORIA Y FILOSOFIA DE JAVA](#cap√≠tulo-1-breve-historia-y-filosofia-de-java)
- [CAP√çTULO 2: CONFIGURACION DEL ENTORNO DE DESARROLLO JDK IDE Y LINEA DE COMANDOS](#cap√≠tulo-2-configuracion-del-entorno-de-desarrollo-jdk-ide-y-linea-de-comandos)
- [CAP√çTULO 3: ESTRUCTURA BASICA DE UN PROGRAMA DE JAVA](#cap√≠tulo-3-estructura-basica-de-un-programa-de-java)
- [CAP√çTULO 4: TIPOS DE DATOS Y VARIABLES](#cap√≠tulo-4-tipos-de-datos-y-variables)
- [CAP√çTULO 5: OPERADORES Y EXPRESIONES](#cap√≠tulo-5-operadores-y-expresiones)
- [CAP√çTULO 6: CONTROL DE FLUJO - IF ELSE SWITCH](#cap√≠tulo-6-control-de-flujo---if-else-switch)
- [CAP√çTULO 7: BUCLES - FOR WHILE DO-WHILE](#capitulo-7-bucles---for-while-do-while)
- [CAP√çTULO 8: METODOS - DEFINICION PARAMETROS Y RETORNO](#cap√≠tulo-8-metodos-definicion-parametros-y-retorno)
- [CAP√çTULO 9: MANEJO DE EXCEPCIONES - TRY CATCH FINALLY](#cap√≠tulo-9-manejo-de-excepciones---try-catch-finally)
- [CAP√çTULO 10: CLASES Y OBJETOS](#cap√≠tulo-10-clases-y-objetos)
- [CAP√çTULO 11: MODIFICADORES DE ACCESO Y ENCAPSULACI√ìN](#cap√≠tulo-11-modificadores-de-acceso-y-encapsulaci√≥n)
- [CAP√çTULO 12: HERENCIA Y POLIMORFISMO](#cap√≠tulo-12-herencia-y-polimorfismo)
- [CAP√çTULO 13: INTERFACES Y CLASES ABSTRACTAS](#cap√≠tulo-13-interfaces-y-clases-abstractas)
- [CAP√çTULO 14: COLECCIONES - ARRAYLIST HASHMAP Y HASHSET](#cap√≠tulo-14-colecciones---arraylist-hashmap-y-hashset)
- [CAP√çTULO 15: CLASES ANIDADAS Y AN√ìNIMAS](#cap√≠tulo-15-clases-anidadas-y-an√≥nimas)
- [CAP√çTULO 16: FLUJOS DE ENTRADA/SALIDA IO EN JAVA](#cap√≠tulo-16-flujos-de-entradasalida-io-en-java)
- [CAP√çTULO 17: LECTURA Y ESCRITURA DE ARCHIVOS DE TEXTO](#cap√≠tulo-17-lectura-y-escritura-de-archivos-de-texto)
- [CAP√çTULO 18: BUFFEREDREADER Y BUFFEREDWRITER PARA DATOS MASIVOS](#cap√≠tulo-18-bufferedreader-y-bufferedwriter-para-datos-masivos)
- [CAP√çTULO 19: MANEJO DE ARCHIVOS BINARIOS EN JAVA](#cap√≠tulo-19-manejo-de-archivos-binarios-en-java)
- [CAP√çTULO 20: SERIALIZACI√ìN DE OBJETOS EN JAVA](#cap√≠tulo-20-serializaci√≥n-de-objetos-en-java)
- [CAP√çTULO 21: INTRODUCCI√ìN A NIO NEW IO EN JAVA](#cap√≠tulo-21-introducci√≥n-a-nio-new-io-en-java)



## CAP√çTULO 1: BREVE HISTORIA Y FILOSOFIA DE JAVA
---

### üîπ 1.1 Breve Historia de Java

A principios de los a√±os 90, **Sun Microsystems** inici√≥ el *Green Project* liderado por **James Gosling**, con el objetivo de crear un lenguaje para dispositivos embebidos como decodificadores.

- El lenguaje inicial se llam√≥ **Oak**, inspirado en un roble cercano a la oficina de Gosling.
- Oak fue dise√±ado para ser **simple, seguro y sin dependencia de hardware**.
- En 1993, con la explosi√≥n de la **World Wide Web**, se vio una nueva oportunidad: ejecutar programas desde el navegador.

En **1995**, Oak fue renombrado como **Java** (por problemas de copyright) y se lanz√≥ junto al navegador **HotJava**.

> Java permiti√≥ ejecutar peque√±os programas (applets) directamente en p√°ginas web, ofreciendo interactividad sin descargar software adicional.

#### üß© ‚ÄúWrite Once, Run Anywhere‚Äù

- **Java** se compila a **bytecode**, un formato intermedio.
- Este bytecode se ejecuta dentro de la **M√°quina Virtual de Java (JVM)**.
- Un mismo programa puede correr en diferentes sistemas operativos **sin modificaciones**.

Esto redujo la complejidad del desarrollo multiplataforma y represent√≥ un **punto de inflexi√≥n en el desarrollo de software**.

---

### üîπ 1.2 La Filosof√≠a de Java

Java fue dise√±ado con una **filosof√≠a clara y pragm√°tica**, basada en estos principios:

---

#### ‚úÖ Simplicidad y Familiaridad
- Inspirado en **C y C++**, pero eliminando:
  - Herencia m√∫ltiple directa
  - Manejo expl√≠cito de punteros
- Resultado: un lenguaje m√°s **f√°cil de aprender y mantener**.

---

#### üåç Portabilidad
- Gracias a la **JVM**, Java puede ejecutarse en cualquier sistema con una JVM compatible.
- Las empresas pueden desarrollar sin preocuparse por el hardware o sistema operativo.

---

#### üîê Seguridad
- Java se ejecuta **aislado del sistema operativo**.
- Protege contra c√≥digo malicioso y garantiza seguridad, especialmente en los **applets**.

---

#### üîÅ Concurrencia y Multitarea
- Desde su inicio, Java incluye **soporte nativo para hilos**.
- Permite ejecutar m√∫ltiples tareas simult√°neamente, facilitando el desarrollo de aplicaciones modernas.

---

#### üõ†Ô∏è Robustez y Manejo de Errores
- Elimina errores comunes como la segmentaci√≥n de memoria (al evitar punteros).
- Sistema estructurado de **manejo de excepciones** para mayor estabilidad.

---

#### ‚ö° Desempe√±o Razonable
- Aunque fue criticado por su lentitud inicial, Java ahora incluye **compilaci√≥n Just-In-Time (JIT)**.
- Esto permite ejecutar c√≥digo a velocidades cercanas al c√≥digo nativo **sin perder portabilidad**.

---

### üîπ 1.3 Impacto y Evoluci√≥n de Java

Desde 1995, Java se expandi√≥ en:

- Aplicaciones empresariales
- Navegadores
- Servidores
- Dispositivos m√≥viles y embebidos
- Supercomputadoras

Con el tiempo, se a√±adieron nuevas caracter√≠sticas:
- **Gen√©ricos**
- **Expresiones lambda**
- **APIs funcionales**

Java cuenta con una gran comunidad y un extenso ecosistema de:
- **Librer√≠as**
- **Frameworks**
- **Herramientas de desarrollo**

> Hoy en d√≠a, Java sigue siendo uno de los lenguajes **m√°s utilizados y valorados**, gracias a su enfoque en la **simplicidad, portabilidad y seguridad**.

---

## CAP√çTULO 2: CONFIGURACION DEL ENTORNO DE DESARROLLO (JDK, IDE Y LINEA DE COMANDOS)

### üîß Preparaci√≥n del Entorno

Antes de programar en Java, es esencial preparar un entorno que permita **escribir, compilar y ejecutar** programas eficientemente. Este cap√≠tulo cubre:

- Instalaci√≥n del **JDK**
- Elecci√≥n de un **IDE**
- Uso de la **l√≠nea de comandos**
- Configuraci√≥n de **variables de entorno**
- Consejos pr√°cticos para un entorno √≥ptimo

---

### ‚òï 2.1 ¬øQu√© es el JDK y por qu√© es necesario?

El **Java Development Kit (JDK)** es un conjunto de herramientas y librer√≠as esenciales para desarrollar en Java.

Incluye:
- `javac`: el compilador (c√≥digo fuente ‚Üí bytecode)
- `jdb`: depurador
- `jar`: herramienta para empaquetar archivos

> El **bytecode** generado se ejecuta en la **JVM** en cualquier sistema operativo.

---

### üì• 2.2 Descarga e Instalaci√≥n del JDK

#### üìå 2.2.1 Identificaci√≥n de la versi√≥n adecuada

- Oracle JDK
- OpenJDK
- Amazon Corretto
- AdoptOpenJDK

> Para aprender, la mejor opci√≥n suele ser la **√∫ltima versi√≥n LTS** por su estabilidad y soporte.

---

#### ‚öôÔ∏è 2.2.2 Proceso de instalaci√≥n

##### ü™ü En Windows
1. Descarga desde [Oracle](https://www.oracle.com/java/technologies/javase-downloads.html) u [OpenJDK](https://openjdk.java.net).
2. Ejecuta el instalador (`.exe`).
3. Sigue el asistente de instalaci√≥n y selecciona una ubicaci√≥n, por ejemplo:  
   `C:\Program Files\Java\jdk-xx`

##### üçé En macOS
1. Descarga el archivo `.pkg`
2. Ejecuta el instalador.
3. El JDK se instalar√° en:  
   `/Library/Java/JavaVirtualMachines/`

##### üêß En Linux
- Opci√≥n 1: Instalar desde archivo `.tar.gz` y configurar variables.
- Opci√≥n 2: Usar gestor de paquetes:

```bash
sudo apt update
sudo apt install openjdk-11-jdk
```

---

### üåê 2.3 Configuraci√≥n de Variables de Entorno

#### üíª En Windows
1. Abre *Panel de Control* ‚Üí "Variables de entorno".
2. Edita la variable `Path`.
3. Agrega la ruta al bin del JDK, por ejemplo:  
   `C:\Program Files\Java\jdk-xx\bin`
4. Reinicia la terminal para aplicar los cambios.

#### üíª En macOS / Linux
1. Edita tu archivo de configuraci√≥n del shell (`~/.bashrc`, `~/.bash_profile`, `~/.zshrc`).

```bash
export JAVA_HOME=/ruta/a/jdk
export PATH=$JAVA_HOME/bin:$PATH
```

2. Aplica los cambios:

```bash
source ~/.bashrc
```

3. Verifica con:

```bash
java -version
javac -version
```

---

### üß† 2.4 Elecci√≥n e Instalaci√≥n de un IDE

#### üîç Opciones Populares

| IDE         | Caracter√≠sticas principales                                     |
|-------------|----------------------------------------------------------------|
| **Eclipse** | Madurez, plugins variados, muy usado profesionalmente         |
| **IntelliJ**| Interfaz fluida, herramientas inteligentes, versi√≥n gratuita   |
| **NetBeans**| F√°cil de usar, listo para Java desde el inicio                 |

#### üõ†Ô∏è Instalaci√≥n

1. Descarga desde el sitio oficial (ej: [IntelliJ IDEA](https://www.jetbrains.com/idea/)).
2. Sigue el asistente de instalaci√≥n.
3. Configura la ruta del JDK si no se detecta autom√°ticamente.

---

### üñ•Ô∏è 2.5 Uso de L√≠nea de Comandos

#### üîÉ Ciclo B√°sico

1. **Escribir el c√≥digo**

```java
// HelloWorld.java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

2. **Compilar**

```bash
javac HelloWorld.java
```

3. **Ejecutar**

```bash
java HelloWorld
```

> Salida esperada:
> ```
> Hello, World!
> ```

---

#### üõ†Ô∏è Soluci√≥n de Problemas Comunes

| Error                                      | Soluci√≥n                                                  |
|-------------------------------------------|-----------------------------------------------------------|
| `java: command not found`                 | Verifica instalaci√≥n y variables de entorno               |
| Error de clase no encontrada              | Aseg√∫rate de compilar correctamente y ejecutar desde el directorio adecuado |
| Nombre del archivo no coincide con la clase p√∫blica | Aseg√∫rate que el nombre del archivo sea el mismo que la clase p√∫blica (`HelloWorld.java`) |

---

### üí° 2.6 Consejos Finales para un Entorno √ìptimo

- üîÅ **Mant√©n actualizado tu JDK**
- ‚öôÔ∏è **Experimenta con distintos IDEs**
- üß± **Aprende comandos b√°sicos**
- üìÅ **Organiza tu c√≥digo por carpetas:**
  - `/src` para c√≥digo fuente
  - `/res` para recursos
  - `/config` para configuraciones

- ‚úÖ **Flujo de trabajo recomendado:**
  1. Editar c√≥digo
  2. Compilar
  3. Ejecutar
  4. Depurar

---

> Dominar esta configuraci√≥n es el primer paso para convertirte en un desarrollador Java s√≥lido y eficiente üöÄ

---

## CAP√çTULO 3: ESTRUCTURA BASICA DE UN PROGRAMA DE JAVA
---

### üß± 3.1 Elementos Fundamentales de un Programa Java

Un programa t√≠pico de Java incluye los siguientes elementos:

---

#### 1. `package`: Organizaci√≥n del c√≥digo

```java
package com.cursojava.proyecto;
```

- Agrupa clases relacionadas.
- Opcional en programas simples.
- Recomendado para proyectos grandes.

---

#### 2. `import`: Inclusi√≥n de clases externas

```java
import java.util.Scanner;
```

- Permite el uso de clases de la API de Java o librer√≠as externas.
- Evita escribir el nombre completo de las clases (como `java.util.Scanner`).

---

#### 3. Clase principal (`public class`)

```java
public class HolaMundo {
    // C√≥digo aqu√≠
}
```

- Toda aplicaci√≥n debe tener al menos una clase p√∫blica.
- El nombre de la clase **debe coincidir** con el nombre del archivo `.java`.

---

#### 4. M√©todo `main`: Punto de entrada

```java
public static void main(String[] args) {
    // Instrucciones del programa
}
```

**Explicaci√≥n de la firma:**
- `public`: accesible desde cualquier parte.
- `static`: se puede ejecutar sin instanciar la clase.
- `void`: no retorna valor.
- `String[] args`: recibe argumentos desde la l√≠nea de comandos.

---

#### 5. Instrucciones dentro del `main`

Aqu√≠ es donde se escribe el c√≥digo que ser√° ejecutado al correr el programa: imprimir mensajes, leer entradas, realizar c√°lculos, etc.

---

### üíª 3.2 Ejemplo Completo de Programa B√°sico

```java
// 1. Paquete opcional
package com.miempresa.proyecto;

// 2. Importaciones necesarias
import java.util.Scanner;

// 3. Clase principal
public class HolaMundo {

    // 4. M√©todo main
    public static void main(String[] args) {

        // 5. Instrucciones
        System.out.println("Hola, Mundo!");

        // Leer entrada del usuario
        Scanner scanner = new Scanner(System.in);
        System.out.print("Introduce tu nombre: ");
        String nombre = scanner.nextLine();

        // Saludo personalizado
        System.out.println("Hola, " + nombre + ", ¬°bienvenido a Java!");
    }
}
```

---

### üìù 3.3 Detalles Clave de la Estructura

#### ‚úÖ Orden correcto:
1. `package`
2. `import`
3. Clase principal
4. M√©todo `main`

#### üìÇ Nombres correctos:
- El archivo debe llamarse **exactamente igual** que la clase p√∫blica.
  - Ej: `HolaMundo.java` ‚Üí `public class HolaMundo`

#### ‚úçÔ∏è Convenciones:
- **Clases**: May√∫scula inicial, estilo *CamelCase* ‚Üí `MiPrimeraClase`
- **M√©todos y variables**: min√∫scula inicial, tambi√©n *camelCase* ‚Üí `mostrarMensaje`
- Usa nombres descriptivos para facilitar el mantenimiento del c√≥digo.

#### üí¨ Comentarios:
- Una l√≠nea: `// Comentario`
- Varias l√≠neas:

```java
/*
Esto es un
comentario multil√≠nea.
*/
```

---

### üõ†Ô∏è 3.4 C√≥mo Compilar y Ejecutar

#### 1. Compilar:

```bash
javac HolaMundo.java
```

> Esto crea el archivo `HolaMundo.class`.

#### 2. Ejecutar:

```bash
java HolaMundo
```

> Resultado en consola:
```
Hola, Mundo!
Introduce tu nombre: Juan
Hola, Juan, ¬°bienvenido a Java!
```

---

### üßæ 3.5 Conclusi√≥n

Comprender la estructura b√°sica de un programa Java te permite:

- Escribir c√≥digo correctamente desde el inicio.
- Identificar errores comunes de compilaci√≥n.
- Prepararte para aprender estructuras m√°s complejas como clases auxiliares, m√©todos personalizados, l√≥gica de control, etc.

> üöÄ *Dominar esta base es el primer paso hacia el desarrollo de aplicaciones Java robustas y profesionales.*

---

## CAP√çTULO 4: TIPOS DE DATOS Y VARIABLES

---

### üß† 4.1 ¬øQu√© es una Variable?

Una **variable** es un espacio en memoria con un nombre √∫nico que se utiliza para almacenar datos. En Java, toda variable debe tener un **tipo de dato** que determine:

- Qu√© puede almacenar.
- Qu√© operaciones pueden realizarse sobre ella.

**Ejemplo:**

```java
int numero = 10;
```

- `int`: tipo de dato (entero).
- `numero`: nombre de la variable.
- `10`: valor almacenado.

---

### üì¶ 4.2 Tipos de Datos en Java

#### 4.2.1 Tipos de Datos Primitivos

Son los bloques b√°sicos. No son objetos y se almacenan directamente:

| Categor√≠a          | Tipo   | Tama√±o  | Rango |
|-------------------|--------|---------|-------|
| Enteros           | `byte` | 8 bits  | -128 a 127 |
|                   | `short`| 16 bits | -32,768 a 32,767 |
|                   | `int`  | 32 bits | -2,147,483,648 a 2,147,483,647 |
|                   | `long` | 64 bits | -9,223,372,036,854,775,808 a 9,223,372,036,854,775,807 |
| Decimales         | `float`| 32 bits | ¬±1.4E-45 a ¬±3.4E38 |
|                   | `double`| 64 bits| ¬±4.9E-324 a ¬±1.7E308 |
| Caracteres        | `char` | 16 bits | '\u0000' a '\uffff' |
| Booleanos         | `boolean` | 1 bit (te√≥rico) | `true` o `false` |

---

#### 4.2.2 Tipos de Datos por Referencia

Contienen **referencias a objetos**:

- **String** (cadenas de texto):
  ```java
  String mensaje = "Hola, mundo";
  ```
- **Arreglos**:
  ```java
  int[] numeros = {1, 2, 3, 4, 5};
  ```
- **Clases/Objetos personalizados**:
  Se declaran a partir de clases definidas por el usuario.

---

### üõ†Ô∏è 4.3 Declaraci√≥n y Asignaci√≥n de Variables

#### Declaraci√≥n + Asignaci√≥n en una sola l√≠nea:
```java
int edad = 30;
```

#### Declaraci√≥n y asignaci√≥n por separado:
```java
int edad;
edad = 30;
```

---

#### 4.3.1 Reglas de Nomenclatura

- Iniciar con letra, guion bajo (`_`) o signo de d√≥lar (`$`).
- No usar palabras reservadas (`class`, `public`, `int`, etc.).
- Usar nombres descriptivos en **camelCase**:

```java
int contadorDeIntentos;
```

---

#### 4.3.2 Ejemplo con Varios Tipos

```java
int numeroEntero = 100;
double precio = 199.99;
boolean esActivo = true;
char inicial = 'A';
String mensaje = "Hola";
```

---

### üßæ 4.4 Inicializaci√≥n y Valores por Defecto

| Tipo de Dato        | Valor por defecto |
|---------------------|-------------------|
| int, byte, short... | 0                 |
| float, double       | 0.0               |
| boolean             | false             |
| char                | '\u0000'          |
| String / referencias| null              |

> Las **variables locales** (dentro de m√©todos) deben ser inicializadas manualmente antes de usarse.

---

### üîÅ 4.5 Conversi√≥n entre Tipos de Datos

#### 1. Conversi√≥n Impl√≠cita (ampliaci√≥n):
```java
int numero = 100;
long numeroLargo = numero;
```

#### 2. Conversi√≥n Expl√≠cita (reducci√≥n):
```java
double valorDecimal = 9.99;
int valorEntero = (int) valorDecimal; // pierde la parte decimal
```

---

### ‚úÖ 4.6 Buenas Pr√°cticas con Variables

- **Usar nombres descriptivos**: en vez de `x`, us√° `edad`, `totalVentas`, etc.
- **Inicializa siempre las variables locales**.
- **Elegir el tipo de dato m√°s adecuado**: no uses `int` si `byte` alcanza.
- **Reducir el alcance**: declaralas en el bloque m√°s peque√±o posible.

---

## CAP√çTULO 5: Operadores y Expresiones

---

### ‚öôÔ∏è 5.1 ¬øQu√© es un Operador?

Un **operador** es un s√≠mbolo que realiza una operaci√≥n sobre uno o m√°s valores llamados **operandos**.

**Ejemplo:**

```java
int resultado = 10 + 5; // resultado = 15
```

---

### üßÆ 5.2 ¬øQu√© es una Expresi√≥n?

Una **expresi√≥n** combina operadores y operandos para producir un valor. Este valor puede ser de cualquier tipo: num√©rico, booleano o una cadena.

**Ejemplo:**

```java
int resultado = 10 + (5 * 2); // resultado = 20
```

---

### üß© 5.3 Clasificaci√≥n de Operadores en Java

#### üî¢ 5.3.1 Operadores Aritm√©ticos

Permiten realizar operaciones matem√°ticas b√°sicas:

| Operador | Significado     |
|----------|-----------------|
| `+`      | Suma            |
| `-`      | Resta           |
| `*`      | Multiplicaci√≥n  |
| `/`      | Divisi√≥n        |
| `%`      | M√≥dulo (resto)  |

**Ejemplo:**

```java
int a = 15, b = 4;
int suma = a + b;       // 19
int resta = a - b;      // 11
int producto = a * b;   // 60
int cociente = a / b;   // 3
int resto = a % b;      // 3
```

---

#### üíæ 5.3.2 Operadores de Asignaci√≥n

Asignan valores a variables. Pueden ser simples o combinados:

| Operador | Ejemplo       | Equivalente        |
|----------|---------------|--------------------|
| `=`      | `x = 10;`     | Asignaci√≥n directa |
| `+=`     | `x += 5;`     | `x = x + 5;`       |
| `-=`     | `x -= 3;`     | `x = x - 3;`       |
| `*=`     | `x *= 2;`     | `x = x * 2;`       |
| `/=`     | `x /= 4;`     | `x = x / 4;`       |
| `%=`     | `x %= 3;`     | `x = x % 3;`       |

---

#### ‚öñÔ∏è 5.3.3 Operadores de Comparaci√≥n (Relacionales)

Comparan valores y devuelven `true` o `false`.

| Operador | Significado       |
|----------|-------------------|
| `==`     | Igual a           |
| `!=`     | Distinto de       |
| `>`      | Mayor que         |
| `<`      | Menor que         |
| `>=`     | Mayor o igual     |
| `<=`     | Menor o igual     |

**Ejemplo:**

```java
int a = 7, b = 5;
boolean esIgual = (a == b);   // false
boolean esMayor = (a > b);    // true
boolean esMenor = (a < b);    // false
```

---

#### üîê 5.3.4 Operadores L√≥gicos

Trabajan con valores booleanos:

| Operador | Significado       |
|----------|-------------------|
| `&&`     | AND l√≥gico        |
| `||`     | OR l√≥gico         |
| `!`      | NOT l√≥gico        |

**Ejemplo:**

```java
boolean cond1 = (5 > 3); // true
boolean cond2 = (10 < 20); // true

boolean resultado = cond1 && cond2;  // true
boolean resultado2 = cond1 || false; // true
boolean negacion = !cond1;           // false
```

---

#### üîÑ 5.3.5 Operadores Unarios

Act√∫an sobre un solo operando:

| Operador | Ejemplo              | Resultado               |
|----------|----------------------|--------------------------|
| `+`      | `+a`                 | Valor positivo           |
| `-`      | `-a`                 | Inverso del valor        |
| `++`     | `a++` / `++a`        | Incrementa en 1          |
| `--`     | `a--` / `--a`        | Decrementa en 1          |
| `!`      | `!true`              | false                    |

**Ejemplo:**

```java
int c = 5;
c++; // c = 6
c--; // c = 5

boolean esVerdadero = true;
boolean esFalso = !esVerdadero; // false
```

---

#### üß† 5.3.6 Operadores Bit a Bit

Trabajan a nivel binario:

| Operador | Descripci√≥n             |
|----------|--------------------------|
| `&`      | AND bit a bit            |
| `|`      | OR bit a bit             |
| `^`      | XOR bit a bit            |
| `~`      | Complemento              |
| `<<`     | Desplazamiento izq.      |
| `>>`     | Desplazamiento der.      |
| `>>>`    | Desplazamiento der. sin signo |

**Ejemplo:**

```java
int num1 = 5; // 0101
int num2 = 3; // 0011
int resultado = num1 & num2; // 0001 ‚Üí 1
```

---

#### üßÆ 5.3.7 Precedencia de Operadores

Java eval√∫a primero los operadores con mayor precedencia.

| Precedencia Alta ‚Üí Baja |
|--------------------------|
| `()` Par√©ntesis          |
| `* / %`                  |
| `+ -`                    |
| Comparaciones (`< > ==`) |
| `&&`                     |
| `||`                     |
| Asignaciones (`=` `+=`)  |

**Ejemplo:**

```java
int resultado1 = 10 + 5 * 2;      // 20
int resultado2 = (10 + 5) * 2;    // 30
```

‚úÖ **Consejo:** us√° par√©ntesis para aclarar el orden y mejorar la legibilidad.

---

### üßº 5.4 Buenas Pr√°cticas con Operadores y Expresiones

- ‚úÖ **Us√° nombres descriptivos:**  
  En vez de `x + y`, mejor `precioProducto + impuesto`.

- ‚úÖ **Divid√≠ expresiones largas:**  
  Us√° variables intermedias para simplificar y aclarar.

- ‚ö†Ô∏è **Cuidado con comparaciones de String:**  
  No uses `==`. En su lugar, us√° `.equals()`:
  
  ```java
  String nombre = "Juan";
  if (nombre.equals("Juan")) {
      // correcto
  }
  ```

---
# CAP√çTULO 6: CONTROL DE FLUJO - IF, ELSE, SWITCH

## üìå Introducci√≥n
El control de flujo permite dirigir la ejecuci√≥n de un programa basado en condiciones. Estas estructuras son fundamentales para crear l√≥gica din√°mica en Java.

```java
// Ejemplo r√°pido:
if (usuarioEsPremium) {
    mostrarContenidoExclusivo();
} else {
    mostrarPublicidad();
}
```

---

## 6.1 ¬øQu√© es el Control de Flujo?
Mecanismo que determina **qu√© instrucciones** se ejecutan y en **qu√© orden**, basado en condiciones.

### üîç Analog√≠a Pr√°ctica
> "Como un sem√°foro: si est√° en verde (true), el coche avanza; si est√° en rojo (false), se detiene."

---

## 6.2 Sentencia `if`
Eval√∫a una condici√≥n booleana para ejecutar un bloque de c√≥digo.

### Estructura B√°sica
```java
if (condici√≥n) {
    // C√≥digo si la condici√≥n es true
}
```

### Ejemplo con Explicaci√≥n Visual
```java
int temperatura = 25;

if (temperatura > 30) {
    System.out.println("¬°Hace calor!");
}
```
‚úÖ **Flujo:**  
`temperatura > 30?` ‚Üí Si es `true`, imprime el mensaje. Si es `false`, lo omite.

---

## 6.3 Sentencia `if-else`
A√±ade una alternativa cuando la condici√≥n es falsa.

### Diagrama de Flujo
```
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ  Condici√≥n  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
      true ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê false
           ‚ñº         ‚ñº
    [Bloque if]  [Bloque else]
```

### Ejemplo Pr√°ctico
```java
int hora = 14;

if (hora < 12) {
    System.out.println("Buenos d√≠as");
} else {
    System.out.println("Buenas tardes"); // ‚Üê Esto se ejecuta
}
```

---

## 6.4 `else-if` y Anidamientos
Para m√∫ltiples condiciones evaluadas en secuencia.

### Buenas Pr√°cticas
- Ordena condiciones de **m√°s restrictiva a menos restrictiva**.
- Evita anidamientos profundos (m√°ximo 3 niveles).

### Ejemplo Claro
```java
int puntuacion = 88;

if (puntuacion >= 90) {
    System.out.println("A");
} else if (puntuacion >= 80) {  // ‚Üê Esta condici√≥n se eval√∫a
    System.out.println("B");    // ‚Üê Se ejecuta
} else {
    System.out.println("C");
}
```

---

## 6.5 Sentencia `switch`
Ideal para comparar **valores concretos** de una variable.

### Estructura Detallada
```java
switch (variable) {
    case valor1:
        // C√≥digo para valor1
        break;  // ‚Üê ¬°Imprescindible!
    case valor2:
        // C√≥digo para valor2
        break;
    default:
        // C√≥digo si no coincide ning√∫n caso
}
```

### Ejemplo con D√≠as de la Semana
```java
int dia = 3;
switch (dia) {
    case 1 -> System.out.println("Lunes");    // Sintaxis moderna (Java 14+)
    case 2 -> System.out.println("Martes");
    case 3 -> System.out.println("Mi√©rcoles"); // ‚Üê Se ejecuta
    default -> System.out.println("D√≠a inv√°lido");
}
```

‚ö†Ô∏è **Advertencia:**  
Olvidar `break` causa *fall-through* (ejecuta todos los casos siguientes).

---

## 6.6 Comparativa: `if-else` vs `switch`

| Caracter√≠stica       | `if-else`                          | `switch`                      |
|----------------------|------------------------------------|-------------------------------|
| **Uso ideal**        | Rangos, condiciones complejas      | Valores discretos y fijos     |
| **Legibilidad**      | Mejor para pocas condiciones       | √ìptima para muchos casos      |
| **Rendimiento**      | Similar en casos simples           | M√°s r√°pido con muchos casos   |

---

## 6.7 Buenas Pr√°cticas üèÜ

1. **Comentarios explicativos** en condiciones no triviales:
   ```java
   // Verifica si el usuario es adulto y tiene suscripci√≥n
   if (edad >= 18 && tieneSuscripcion) { ... }
   ```

2. **Evita redundancia**:
   ```java
   // ‚ùå Mal
   if (condicion == true) { ... }
   
   // ‚úÖ Bien
   if (condicion) { ... }
   ```

3. **Usa `switch` con expresiones** (Java 14+):
   ```java
   String resultado = switch (modo) {
       case "A" -> "Modo Avanzado";
       case "B" -> "Modo B√°sico";
       default -> "Desconocido";
   };
   ```

---

## üìö Resumen Clave
- **`if`**: Para decisiones binarias (true/false).
- **`else-if`**: Para m√∫ltiples caminos exclusivos.
- **`switch`**: Para selecci√≥n entre valores concretos.
- **Legibilidad > Clever Code**: Elige la estructura que haga el c√≥digo m√°s comprensible.

```java
// Ejemplo integrado
String clima = "lluvia";

if (clima.equals("soleado")) {
    System.out.println("Parque");
} else if (clima.equals("nublado")) {
    System.out.println("Museo");
} else {
    System.out.println("Netflix en casa"); // ‚Üê Esto se ejecutar√≠a
}
```
---
## Capitulo 7 Bucles - For While Do-While


### üéØ Introducci√≥n
Los bucles automatizan tareas repetitivas, evitando c√≥digo redundante. Java ofrece tres tipos:

```java
// Ejemplo integrado
for (int i = 0; i < 3; i++) {
    System.out.println("Iteraci√≥n " + i); // Se ejecuta 3 veces
}```

## 7.1 ¬øQu√© es un Bucle?
Mecanismo que **repite c√≥digo** mientras se cumpla una condici√≥n. Cada repetici√≥n se llama **iteraci√≥n**.

### Casos de Uso Comunes
- ‚úÖ Procesar colecciones de datos
- ‚úÖ Validar entradas de usuario
- ‚úÖ Generar secuencias num√©ricas

---

## 7.2 Bucle `for`
Ideal cuando se conoce el n√∫mero de iteraciones de antemano.

### Estructura Detallada
```java
for (inicializaci√≥n; condici√≥n; actualizaci√≥n) {
    // Cuerpo del bucle
}
```

### Ejemplo Visual
```java
for (int i = 1; i <= 3; i++) {
    System.out.println("‚≠ê Iteraci√≥n " + i);
}
```
**Salida:**
```
‚≠ê Iteraci√≥n 1
‚≠ê Iteraci√≥n 2
‚≠ê Iteraci√≥n 3
```

### Variaciones √ötiles
| Tipo                | Ejemplo                      | Uso                          |
|---------------------|------------------------------|------------------------------|
| **Decreciente**     | `for (int i=5; i>0; i--)`    | Cuentas regresivas           |
| **Pasos personalizados** | `for (int i=0; i<10; i+=2)` | Procesar elementos pares     |

### Recorrido de Arrays
```java
String[] frutas = {"Manzana", "Banana", "Pera"};
for (int i = 0; i < frutas.length; i++) {
    System.out.println(frutas[i]); // Acceso por √≠ndice
}
```

---

## 7.3 Bucle `while`
Flexible para condiciones din√°micas o desconocidas.

### Diagrama de Flujo
```
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ  Condici√≥n  ‚îÇ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
             ‚îÇ             ‚îÇ
        true ‚îÇ             ‚îÇ
             ‚ñº             ‚îÇ
      [Cuerpo bucle]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Ejemplo con Validaci√≥n
```java
Scanner scanner = new Scanner(System.in);
String input = "";

while (!input.equals("salir")) {
    System.out.print("Escribe 'salir' para terminar: ");
    input = scanner.nextLine();
}
```

‚ö†Ô∏è **¬°Cuidado con los bucles infinitos!**  
Siempre asegura que la condici√≥n pueda volverse `false`.

---

## 7.4 Bucle `do-while`
Garantiza **al menos una ejecuci√≥n** antes de evaluar la condici√≥n.

### Ejemplo Pr√°ctico
```java
int numero;
do {
    System.out.print("Ingresa un n√∫mero positivo: ");
    numero = scanner.nextInt();
} while (numero <= 0);
```

**Diferencia clave vs `while`:**  
El cuerpo se ejecuta primero, luego se verifica la condici√≥n.

---

## 7.5 Comparativa: ¬øCu√°l Usar?

| Caracter√≠stica       | `for`                     | `while`                   | `do-while`               |
|----------------------|---------------------------|---------------------------|--------------------------|
| **Evaluaci√≥n**       | Al inicio                 | Al inicio                 | Al final                 |
| **Iteraciones**      | Conocidas                 | Din√°micas                 | ‚â• 1 obligatoria          |
| **Casos t√≠picos**    | Recorrer arrays           | Esperar eventos           | Men√∫s interactivos       |

---

## 7.6 Buenas Pr√°cticas üõ†Ô∏è

1. **Nombres significativos**:
   ```java
   // ‚ùå Poco claro
   for (int i = 0; i < n; i++)
   
   // ‚úÖ Mejor
   for (int productoIdx = 0; productoIdx < totalProductos; productoIdx++)
   ```

2. **Evitar complejidad**:
   ```java
   // ‚ùå Dif√≠cil de mantener
   while ((x > 0 && y < 100) || !terminado) { ... }
   
   // ‚úÖ Refactorizado
   boolean debeContinuar = (x > 0 && y < 100) || !terminado;
   while (debeContinuar) { ... }
   ```

3. **ForEach para colecciones** (Java 5+):
   ```java
   List<String> nombres = List.of("Ana", "Luis", "Marta");
   for (String nombre : nombres) {
       System.out.println(nombre); // M√°s legible
   }
   ```

4. **Control de flujo con `break`/`continue`**:
   ```java
   for (int i = 0; i < 10; i++) {
       if (i == 5) break;    // Sale del bucle
       if (i % 2 == 0) continue; // Salta a la siguiente iteraci√≥n
       System.out.println(i);
   }
   ```

---

## üîÅ Ejemplo Integrado
```java
// Suma n√∫meros hasta que el usuario ingrese 0
Scanner sc = new Scanner(System.in);
int suma = 0;
int numero;

do {
    System.out.print("Ingresa un n√∫mero (0 para salir): ");
    numero = sc.nextInt();
    suma += numero;
} while (numero != 0);

System.out.println("La suma total es: " + suma);
```

---

## üìå Resumen Clave
- **`for`**: Iteraciones predecibles (ej: procesar array).
- **`while`**: Condiciones complejas/din√°micas (ej: esperar respuesta v√°lida).
- **`do-while`**: Ejecuci√≥n m√≠nima garantizada (ej: men√∫s interactivos).

```java
// Elecci√≥n basada en requisitos
if (iteracionesConocidas) {
    usaFor();
} else if (validacionPrevia) {
    usaWhile();
} else {
    usaDoWhile();
}
```
---

# CAP√çTULO 8: M√âTODOS - DEFINICI√ìN, PAR√ÅMETROS Y RETORNO

## üß© Introducci√≥n
Los m√©todos son bloques de c√≥digo reutilizables que organizan la l√≥gica de un programa. Act√∫an como "subrutinas" con un prop√≥sito espec√≠fico.

```java
// Analog√≠a: Un m√©todo es como una caja negra
public int sumar(int a, int b) {
    return a + b; // Entradas ‚Üí Procesamiento ‚Üí Salida
}
```

---

## 8.1 ¬øQu√© es un M√©todo?
Bloque de c√≥digo independiente que:
- ‚úÖ Realiza una tarea espec√≠fica
- ‚úÖ Puede recibir datos (par√°metros)
- ‚úÖ Puede devolver resultados

### Beneficios Clave
| Ventaja          | Ejemplo                  |
|------------------|--------------------------|
| **Reutilizaci√≥n** | Llamar `calcularIVA()` m√∫ltiples veces |
| **Modularidad**  | Dividir un programa complejo en partes peque√±as |
| **Legibilidad**  | `ordenarLista()` vs 20 l√≠neas de c√≥digo desordenado |

---

## 8.2 Anatom√≠a de un M√©todo
```java
[modificadores] tipoRetorno nombreM√©todo([par√°metros]) {
    // Cuerpo
    return valor; // Opcional si no es void
}
```

### Componentes Explicados
1. **Modificadores** (ej: `public static`)
2. **Tipo de retorno** (`void` si no devuelve nada)
3. **Nombre** (camelCase descriptivo)
4. **Par√°metros** (datos de entrada)
5. **Cuerpo** (l√≥gica del m√©todo)
6. **Return** (devuelve un valor del tipo declarado)

---

## 8.3 M√©todo B√°sico (Sin Par√°metros/Retorno)
```java
public void mostrarMenu() {
    System.out.println("1. Iniciar");
    System.out.println("2. Configurar");
    System.out.println("3. Salir");
}
```
**Uso:**  
`mostrarMenu();` ‚Üí Muestra las 3 opciones

---

## 8.4 M√©todos con Par√°metros
Paso de datos externos al m√©todo:

### Ejemplo con 1 Par√°metro
```java
public void saludar(String nombre) {
    System.out.printf("¬°Hola, %s!%n", nombre);
}
```
**Llamada:**  
`saludar("Ana");` ‚Üí Output: `¬°Hola, Ana!`

### Ejemplo con M√∫ltiples Par√°metros
```java
public void registrarUsuario(String username, String email, int edad) {
    // L√≥gica de registro
}
```

---

## 8.5 M√©todos con Retorno
Devuelven un resultado procesado:

### Ejemplo: Conversi√≥n de Unidades
```java
public double celsiusAFahrenheit(double celsius) {
    return (celsius * 9/5) + 32;
}
```
**Uso:**  
```java
double fahr = celsiusAFahrenheit(25.0);
System.out.println("25¬∞C = " + fahr + "¬∞F");
```

### Flujo de Retorno
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   M√©todo    ‚îÇ ‚Üí  ‚îÇ   Return    ‚îÇ ‚Üí  ‚îÇ   Variable  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 8.6 Buenas Pr√°cticas üèÜ

### 1. Nombres Autoexplicativos
```java
// ‚ùå Mal
public void p(double a) {...}

// ‚úÖ Bien
public void imprimirAreaCirculo(double radio) {...}
```

### 2. Principio de √önica Responsabilidad
```java
// ‚ùå M√©todo que hace demasiado
public void procesarPedido() {
    // 50 l√≠neas de c√≥digo
}

// ‚úÖ Dividido en sub-m√©todos
public void procesarPedido() {
    validarStock();
    calcularTotal();
    enviarConfirmacion();
}
```

### 3. L√≠mite de Par√°metros
- **M√°ximo 3-4 par√°metros** por m√©todo
- Alternativas:
  ```java
  // Usar objetos para agrupar datos
  public void crearUsuario(Usuario usuario) {...}
  ```

### 4. Documentaci√≥n con JavaDoc
```java
/**
 * Calcula el inter√©s compuesto
 * @param capital Inversi√≥n inicial
 * @param tasa Tasa anual (ej: 0.05 para 5%)
 * @param a√±os Per√≠odo en a√±os
 * @return Monto final con intereses
 */
public double calcularInteres(double capital, double tasa, int a√±os) {...}
```

---

## üìä Ejemplo Integrado
```java
public class Calculadora {
    
    // M√©todo est√°tico (no necesita instancia)
    public static int maximo(int a, int b) {
        return (a > b) ? a : b;
    }
    
    public static void main(String[] args) {
        int mayor = maximo(15, 8);
        System.out.println("El mayor es: " + mayor);
    }
}
```

---

## üîë Puntos Clave
- **Modulariza** tu c√≥digo en m√©todos espec√≠ficos
- **Par√°metros** permiten generalizar comportamientos
- **Return** comunica resultados al llamante
- **Nombres claros** mejoran la mantenibilidad

```java
// Comparaci√≥n antes/despu√©s
// ‚ùå C√≥digo monol√≠tico
// ‚úÖ C√≥digo organizado en m√©todos
```

---

# CAP√çTULO 9: MANEJO DE EXCEPCIONES - TRY, CATCH, FINALLY

## üö® Introducci√≥n
Las excepciones son eventos que interrumpen el flujo normal de un programa. Java proporciona mecanismos elegantes para manejarlas:

```java
try {
    // C√≥digo riesgoso
    int resultado = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("¬°Error matem√°tico!");
} finally {
    System.out.println("Siempre se ejecuta");
}
```

---

## 9.1 ¬øQu√© es una Excepci√≥n?
Evento que ocurre durante la ejecuci√≥n y requiere manejo especial.

### Tipos de Excepciones
| Tipo                | Ejemplo                  | ¬øObligatorio manejar? |
|---------------------|--------------------------|-----------------------|
| **Comprobadas**     | `IOException`            | S√≠ (Checked)          |
| **No comprobadas**  | `NullPointerException`   | No (Unchecked)        |
| **Errores**         | `OutOfMemoryError`       | No (Fatal)            |

### Ejemplo Com√∫n
```java
String texto = null;
System.out.println(texto.length()); // Lanza NullPointerException
```

---

## 9.2 Estructura Try-Catch
Mecanismo b√°sico para capturar y manejar excepciones.

### Diagrama de Flujo
```
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ    try      ‚îÇ ‚Üê‚îÄ‚îÄ‚îê
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
             ‚îÇ           ‚îÇ
        ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïß‚ïê‚ïê‚ïê‚ïê‚ïó     ‚îÇ
        ‚ïë Excepci√≥n‚ïë ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ï§‚ïê‚ïê‚ïê‚ïê‚ïù
             ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ   catch    ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Ejemplo B√°sico
```java
try {
    FileReader file = new FileReader("archivo.txt");
} catch (FileNotFoundException e) {
    System.out.println("¬°Archivo no encontrado!");
    e.printStackTrace(); // Para depuraci√≥n
}
```

---

## 9.3 M√∫ltiples Bloques Catch
Captura diferentes excepciones espec√≠ficamente:

```java
try {
    // C√≥digo que puede fallar
    int[] nums = {1, 2};
    System.out.println(nums[5]); // ArrayIndexOutOfBounds
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("√çndice inv√°lido");
} catch (RuntimeException e) {
    System.out.println("Error en tiempo de ejecuci√≥n");
}
```

üìå **Orden de captura:** Siempre de m√°s espec√≠fica a m√°s gen√©rica.

---

## 9.4 Bloque Finally
Se ejecuta **siempre**, haya o no excepciones.

### Casos de Uso Comunes
- Cerrar recursos (archivos, conexiones)
- Liberar memoria
- Registrar finalizaci√≥n de procesos

```java
Connection conn = null;
try {
    conn = DriverManager.getConnection(url);
    // Operaciones con BD...
} catch (SQLException e) {
    System.out.println("Error de BD");
} finally {
    if (conn != null) {
        conn.close(); // Importante liberar recursos
    }
}
```

---

## 9.5 Ejemplo Integrado
Programa seguro para divisi√≥n de n√∫meros:

```java
import java.util.InputMismatchException;
import java.util.Scanner;

public class DivisionSegura {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        try {
            System.out.print("Numerador: ");
            int a = sc.nextInt();
            
            System.out.print("Denominador: ");
            int b = sc.nextInt();
            
            System.out.println("Resultado: " + (a/b));
            
        } catch (InputMismatchException e) {
            System.out.println("Error: Debes ingresar n√∫meros");
        } catch (ArithmeticException e) {
            System.out.println("Error: No se puede dividir por cero");
        } finally {
            sc.close();
            System.out.println("Programa finalizado");
        }
    }
}
```

---

## 9.6 Buenas Pr√°cticas üõ°Ô∏è

### 1. S√© Espec√≠fico en las Capturas
```java
// ‚ùå Mal (demasiado gen√©rico)
catch (Exception e) {...}

// ‚úÖ Bien
catch (FileNotFoundException e) {...}
```

### 2. Validaci√≥n vs Excepciones
```java
// Mejor prevenir que capturar
if (divisor != 0) {
    resultado = dividendo / divisor;
} else {
    System.out.println("Divisor no puede ser cero");
}
```

### 3. Logging de Excepciones
```java
catch (SQLException e) {
    // Registrar en archivo log
    Logger.log(e.getMessage());
    // Re-lanzar si es necesario
    throw new MiExcepcionPersonalizada("Error en BD", e);
}
```

### 4. Recursos con Try-With-Resources
```java
// Java 7+ - Cierre autom√°tico
try (FileInputStream fis = new FileInputStream("file.txt")) {
    // Usar recurso...
} catch (IOException e) {
    // Manejo de error
}
```

---

## üìö Resumen Clave
- **`try`**: Delimita c√≥digo riesgoso
- **`catch`**: Maneja excepciones espec√≠ficas
- **`finally`**: Siempre se ejecuta (ideal para limpieza)
- **Jerarqu√≠a**: `Exception` > `RuntimeException` > Excepciones espec√≠ficas


> **Regla de oro**: "Usa excepciones para lo excepcional, no para control de flujo regular"
```

---

# CAP√çTULO 10: CLASES Y OBJETOS

## üß± Introducci√≥n a POO
La Programaci√≥n Orientada a Objetos (POO) organiza el c√≥digo en estructuras llamadas clases, que sirven como planos para crear objetos.

```java
// Analog√≠a: Clase = Molde de galletas | Objeto = Galleta concreta
public class Galleta {
    String sabor;
    String forma;
}
```

---

## 10.1 ¬øQu√© es una Clase?
Plantilla que define:
- **Atributos** (variables que almacenan estado)
- **M√©todos** (funciones que definen comportamiento)

### Ejemplo Completo
```java
public class CuentaBancaria {
    // Atributos
    String titular;
    double saldo;
    
    // M√©todos
    public void depositar(double monto) {
        saldo += monto;
    }
    
    public void retirar(double monto) {
        if (monto <= saldo) {
            saldo -= monto;
        }
    }
}
```

---

## 10.2 Objetos: Instancias de Clases
Cada objeto tiene:
- **Estado √∫nico** (valores de atributos)
- **Comportamiento** (m√©todos disponibles)

### Creaci√≥n y Uso
```java
public class Main {
    public static void main(String[] args) {
        // Instanciaci√≥n
        CuentaBancaria cuentaMaria = new CuentaBancaria();
        
        // Modificar estado
        cuentaMaria.titular = "Mar√≠a L√≥pez";
        cuentaMaria.saldo = 1000.0;
        
        // Usar m√©todos
        cuentaMaria.depositar(500.0);
        cuentaMaria.retirar(200.0);
    }
}
```

### Representaci√≥n Visual
```
Objeto: cuentaMaria
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  CuentaBancaria      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ titular  ‚îÇ "Mar√≠a L."‚îÇ
‚îÇ saldo    ‚îÇ 1300.0    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 10.3 Relaci√≥n Clase-Objeto
| Concepto      | Ejemplo Mundo Real       | Ejemplo Java               |
|---------------|--------------------------|----------------------------|
| **Clase**     | Plano arquitect√≥nico     | `class Casa {...}`         |
| **Objeto**    | Casa construida          | `Casa miCasa = new Casa()` |

### Multiples Instancias
```java
CuentaBancaria cuentaJuan = new CuentaBancaria();
cuentaJuan.titular = "Juan P√©rez";
cuentaJuan.saldo = 500.0;

// Ambos objetos comparten estructura pero tienen estado independiente
```

---

## 10.4 Constructores
M√©todos especiales que inicializan objetos al crearlos.

### Constructor B√°sico
```java
public class Persona {
    String nombre;
    int edad;
    
    // Constructor
    public Persona(String nombre, int edad) {
        this.nombre = nombre;
        this.edad = edad;
    }
}

// Uso:
Persona p1 = new Persona("Ana", 25);
```

### Reglas Clave
1. Mismo nombre que la clase
2. No tiene tipo de retorno
3. Puede tener par√°metros
4. `this` diferencia atributos de par√°metros

### Tipos de Constructores
| Tipo                | Ejemplo                      |
|---------------------|------------------------------|
| **Por defecto**     | `Persona p = new Persona();` |
| **Parametrizado**   | `new Persona("Luis", 30);`   |
| **Copia**           | `new Persona(otraPersona);`  |

---

## 10.5 Buenas Pr√°cticas üèóÔ∏è

### 1. Encapsulamiento
```java
public class Cuenta {
    private double saldo; // Atributo privado
    
    public double getSaldo() { // M√©todo p√∫blico
        return saldo;
    }
}
```

### 2. Convenci√≥n de Nombres
- Clases: `PascalCase` (`CuentaBancaria`)
- Objetos: `camelCase` (`miCuenta`)
- M√©todos: verbos (`calcularTotal()`)

### 3. Diagramas UML B√°sicos
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Persona      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ - nombre: String ‚îÇ
‚îÇ - edad: int      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + caminar()      ‚îÇ
‚îÇ + hablar()       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 4. Cohesi√≥n Alta
```java
// ‚ùå Mal (mezcla responsabilidades)
class Usuario {
    void login() {...}
    void enviarEmail() {...}
}

// ‚úÖ Bien (responsabilidad √∫nica)
class Autenticador {
    void login() {...}
}

class Notificador {
    void enviarEmail() {...}
}
```

---

## üîÑ Ejemplo Integrado
```java
public class Libro {
    private String titulo;
    private String autor;
    private int paginas;
    
    // Constructor
    public Libro(String titulo, String autor, int paginas) {
        this.titulo = titulo;
        this.autor = autor;
        this.paginas = paginas;
    }
    
    // M√©todos
    public String getInfo() {
        return titulo + " por " + autor + " (" + paginas + " p√°gs)";
    }
    
    public static void main(String[] args) {
        Libro libro1 = new Libro("Cien a√±os de soledad", "Garc√≠a M√°rquez", 432);
        System.out.println(libro1.getInfo());
    }
}
```

---

## üìå Puntos Clave
1. **Clases** son modelos abstractos
2. **Objetos** son instancias concretas
3. **new** crea nuevos objetos
4. **Constructores** inicializan estado
5. **this** referencia al objeto actual

```mermaid
classDiagram
    class Libro {
        -String titulo
        -String autor
        -int paginas
        +Libro(String, String, int)
        +getInfo() String
    }
```

> "La POO no trata solo de escribir c√≥digo, sino de modelar soluciones" - Grady Booch
```

---

# CAP√çTULO 11: MODIFICADORES DE ACCESO Y ENCAPSULACI√ìN

## üîí Introducci√≥n
La encapsulaci√≥n es uno de los 4 pilares de la POO que protege los datos internos de un objeto, exponiendo solo lo necesario mediante una interfaz controlada.

```java
// Ejemplo b√°sico
public class Cuenta {
    private double saldo; // Atributo encapsulado
    
    public double getSaldo() { // Interfaz p√∫blica
        return saldo;
    }
}
```

---

## 11.1 Modificadores de Acceso en Java
Controlan desde d√≥nde se puede acceder a clases, atributos y m√©todos.

### Tabla Comparativa
| Modificador   | Misma Clase | Mismo Paquete | Subclases | Otros Paquetes |
|---------------|-------------|---------------|-----------|----------------|
| `private`     | ‚úÖ          | ‚ùå            | ‚ùå        | ‚ùå             |
| `default`     | ‚úÖ          | ‚úÖ            | ‚ùå        | ‚ùå             |
| `protected`   | ‚úÖ          | ‚úÖ            | ‚úÖ        | ‚ùå             |
| `public`      | ‚úÖ          | ‚úÖ            | ‚úÖ        | ‚úÖ             |

---

## 11.2 Uso Detallado por Modificador

### 1. Private (M√°xima Restricci√≥n)
```java
public class Persona {
    private String dni; // Solo accesible dentro de Persona
    
    private void validarDNI() {
        // L√≥gica privada
    }
}
```

### 2. Default (Paquete)
```java
class Utilidad { // Sin modificador -> default
    String formato; // Visible solo en su paquete
}
```

### 3. Protected (Herencia)
```java
public class Animal {
    protected String especie; // Visible en herencia
    
    protected void comer() {
        System.out.println("Comiendo...");
    }
}
```

### 4. Public (Sin Restricciones)
```java
public class Mensaje {
    public String texto; // Accesible desde cualquier lugar
    
    public void mostrar() {
        System.out.println(texto);
    }
}
```

---

## 11.3 Encapsulaci√≥n en Profundidad
Principio que oculta los detalles internos y expone solo una interfaz segura.

### Beneficios Clave
- üõ°Ô∏è **Protecci√≥n de datos**: Evita modificaciones incorrectas
- üîß **Mantenibilidad**: Cambios internos no afectan otros componentes
- üìù **Validaciones**: Control en asignaci√≥n de valores

### Anti-Patr√≥n (Sin Encapsulaci√≥n)
```java
public class Punto {
    public int x; // ‚ùå Riesgo: Modificaci√≥n directa
    public int y;
}
```

---

## 11.4 Getters y Setters
M√©todos p√∫blicos para acceder/modificar atributos privados.

### Implementaci√≥n Est√°ndar
```java
public class Producto {
    private String nombre;
    private double precio;
    
    // Getter
    public String getNombre() {
        return nombre;
    }
    
    // Setter con validaci√≥n
    public void setPrecio(double precio) {
        if (precio >= 0) {
            this.precio = precio;
        } else {
            throw new IllegalArgumentException("Precio no v√°lido");
        }
    }
}
```

### Tipos Especiales
| M√©todo          | Ejemplo                | Uso                          |
|-----------------|------------------------|------------------------------|
| **Boolean Getter** | `isActivo()`         | Para atributos boolean       |
| **Immutable**   | Sin setters           | Objetos que no deben cambiar |

---

## 11.5 Buenas Pr√°cticas üèÜ

### 1. Regla del 100%
> "Todos los atributos deben ser `private` a menos que haya una raz√≥n de peso para no hacerlo"

### 2. Validaciones en Setters
```java
public void setEdad(int edad) {
    if (edad < 0 || edad > 120) {
        throw new IllegalArgumentException("Edad inv√°lida");
    }
    this.edad = edad;
}
```

### 3. M√©todos de Acceso Inteligentes
```java
public String getNombreCompleto() {
    return nombre + " " + apellido; // Calculado al vuelo
}
```

### 4. Inmutabilidad
```java
public final class Direccion {
    private final String calle; // Final + private
    
    public Direccion(String calle) {
        this.calle = calle;
    }
    
    // Solo getter, sin setter
    public String getCalle() {
        return calle;
    }
}
```

---

## üîÑ Ejemplo Integrado
```java
public class CuentaBancaria {
    private String titular;
    private double saldo;
    private String numeroCuenta;
    
    public CuentaBancaria(String titular, String numeroCuenta) {
        this.titular = titular;
        this.numeroCuenta = numeroCuenta;
        this.saldo = 0.0;
    }
    
    // Getters
    public String getTitular() { return titular; }
    public double getSaldo() { return saldo; }
    
    // Setters protegidos
    public void depositar(double monto) {
        if (monto > 0) {
            saldo += monto;
        }
    }
    
    public boolean retirar(double monto) {
        if (monto > 0 && saldo >= monto) {
            saldo -= monto;
            return true;
        }
        return false;
    }
}
```

---

## üìå Puntos Clave
1. **`private`** es el modificador por defecto recomendado
2. Los **getters/setters** son la puerta de acceso controlado
3. La **inmutabilidad** previene efectos secundarios
4. **Validaciones** en setters garantizan consistencia

```mermaid
classDiagram
    class CuentaBancaria {
        -String titular
        -double saldo
        -String numeroCuenta
        +getTitular() String
        +getSaldo() double
        +depositar(double) void
        +retirar(double) boolean
    }
```

> "La encapsulaci√≥n no se trata de ocultar datos, sino de proteger invariantes" - Barbara Liskov
```

---

# CAP√çTULO 12: HERENCIA Y POLIMORFISMO

## üß¨ Introducci√≥n
La herencia y el polimorfismo son dos pilares fundamentales de la POO que permiten:
- **Reutilizar c√≥digo** (herencia)
- **Extender funcionalidad** (sobreescritura)
- **Crear interfaces flexibles** (polimorfismo)

```java
// Ejemplo base
class Animal {
    void hacerSonido() {
        System.out.println("Sonido gen√©rico");
    }
}

class Perro extends Animal {
    @Override
    void hacerSonido() {
        System.out.println("Guau guau!");
    }
}
```

---

## 12.1 Herencia en Java
Mecanismo donde una clase (subclase) adquiere atributos y m√©todos de otra (superclase).

### Sintaxis B√°sica
```java
public class Vehiculo { // Superclase
    protected String marca;
    
    public void arrancar() {
        System.out.println("Vehiculo arrancado");
    }
}

public class Coche extends Vehiculo { // Subclase
    private int puertas;
    
    public void abrirPuertas() {
        System.out.println("Abriendo " + puertas + " puertas");
    }
}
```

### Ventajas Clave
- ‚ôªÔ∏è **Reutilizaci√≥n de c√≥digo**
- üèóÔ∏è **Jerarqu√≠as l√≥gicas**
- üß© **Extensibilidad**

---

## 12.2 Relaci√≥n Superclase-Subclase

### Diagrama UML
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Vehiculo      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + marca: String  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + arrancar()     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Coche       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ - puertas: int   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + abrirPuertas() ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Uso Pr√°ctico
```java
Coche miCoche = new Coche();
miCoche.marca = "Toyota";  // Atributo heredado
miCoche.arrancar();        // M√©todo heredado
```

---

## 12.3 Palabra Clave `super`
Referencia a la superclase, √∫til para:
1. Llamar al constructor padre
2. Acceder a m√©todos/atributos sobrescritos

### Ejemplo Constructor
```java
public class Animal {
    protected String nombre;
    
    public Animal(String nombre) {
        this.nombre = nombre;
    }
}

public class Perro extends Animal {
    private String raza;
    
    public Perro(String nombre, String raza) {
        super(nombre); // Llama al constructor de Animal
        this.raza = raza;
    }
}
```

---

## 12.4 Polimorfismo
Capacidad de un objeto para tomar muchas formas.

### Tipos en Java
| Tipo                  | Ejemplo                      | Caracter√≠stica                 |
|-----------------------|------------------------------|--------------------------------|
| **Sobrecarga**        | `sumar(int, int)` vs `sumar(double, double)` | Mismo nombre, distintos par√°metros |
| **Sobreescritura**    | `@Override hacerSonido()`    | Redefinici√≥n en subclases      |

---

## 12.5 Sobreescritura de M√©todos
Reimplementaci√≥n de un m√©todo heredado.

### Reglas Clave
1. Mismo nombre y firma
2. Mismo tipo retorno o subtipo (covarianza)
3. No reducir visibilidad
4. Usar `@Override`

```java
class Figura {
    public void dibujar() {
        System.out.println("Dibujando figura gen√©rica");
    }
}

class Circulo extends Figura {
    @Override
    public void dibujar() {
        System.out.println("Dibujando c√≠rculo");
    }
}
```

---

## 12.6 Sobrecarga de M√©todos
M√∫ltiples versiones de un m√©todo en la misma clase.

### Ejemplo
```java
public class Calculadora {
    // Versi√≥n para enteros
    public int sumar(int a, int b) {
        return a + b;
    }
    
    // Versi√≥n para decimales
    public double sumar(double a, double b) {
        return a + b;
    }
    
    // Versi√≥n para tres n√∫meros
    public int sumar(int a, int b, int c) {
        return a + b + c;
    }
}
```

---

## 12.7 Polimorfismo en Tiempo de Ejecuci√≥n
Java decide qu√© m√©todo ejecutar en tiempo de ejecuci√≥n.

### Ejemplo Cl√°sico
```java
Animal miAnimal = new Perro();
miAnimal.hacerSonido(); // Output: "Guau guau!" (no "Sonido gen√©rico")
```

### Reglas
1. Se usa el tipo real del objeto (no la referencia)
2. Solo aplica a m√©todos sobrescritos
3. No aplica a atributos (se usa el de la referencia)

---

## 12.8 Buenas Pr√°cticas üèÖ

### 1. Dise√±o para Extensi√≥n
```java
public class Figura {
    // M√©todo dise√±ado para ser sobrescrito
    public double calcularArea() {
        throw new UnsupportedOperationException();
    }
}
```

### 2. Evitar Herencia Profunda
> "Prefiera composici√≥n sobre herencia" - Effective Java

### 3. M√©todos Finales
```java
public class Seguridad {
    // No puede ser sobrescrito
    public final void validar() {
        // L√≥gica cr√≠tica
    }
}
```

### 4. Clases Abstractas vs Interfaces
| Caracter√≠stica       | Clase Abstracta         | Interface               |
|----------------------|-------------------------|-------------------------|
| **M√©todos**          | Con/sin implementaci√≥n  | Todos abstractos (Java <8) |
| **Atributos**        | Pueden tener estado     | Solo constantes         |
| **Herencia M√∫ltiple**| No                      | S√≠                      |

---

## üîÑ Ejemplo Integrado
```java
public class Empleado {
    protected String nombre;
    
    public Empleado(String nombre) {
        this.nombre = nombre;
    }
    
    public double calcularSalario() {
        return 0;
    }
}

public class Vendedor extends Empleado {
    private double ventas;
    
    public Vendedor(String nombre, double ventas) {
        super(nombre);
        this.ventas = ventas;
    }
    
    @Override
    public double calcularSalario() {
        return 1500 + (ventas * 0.1);
    }
}

// Uso polim√≥rfico
Empleado emp = new Vendedor("Ana", 5000);
System.out.println("Salario: " + emp.calculadorSalario());
```

---

## üìå Puntos Clave
1. **`extends`** establece herencia
2. **`super`** accede a la superclase
3. **`@Override`** marca sobreescritura
4. **Polimorfismo** = mismo interfaz, m√∫ltiples implementaciones
5. **Sobrecarga** ‚â† Sobreescritura

```mermaid
classDiagram
    class Empleado {
        <<abstract>>
        +String nombre
        +calcularSalario()* double
    }
    
    class Vendedor {
        +double ventas
        +calcularSalario() double
    }
    
    Empleado <|-- Vendedor
```

> "El polimorfismo es la capacidad de tratar objetos especializados como si fueran instancias generales" - Bjarne Stroustrup
```

---
# CAP√çTULO 13: INTERFACES Y CLASES ABSTRACTAS

## üß© Introducci√≥n
Las interfaces y clases abstractas son mecanismos fundamentales en Java para:
- **Definir contratos** (interfaces)
- **Proveer implementaciones base** (clases abstractas)
- **Establecer jerarqu√≠as flexibles**

```java
// Ejemplo base
abstract class Animal {
    abstract void hacerSonido();
}

interface Volador {
    void volar();
}

class Pajaro extends Animal implements Volador {
    void hacerSonido() { System.out.println("P√≠o p√≠o"); }
    public void volar() { System.out.println("Volando alto"); }
}
```

---

## 13.1 Clases Abstractas
Plantillas que no pueden instanciarse directamente y pueden contener m√©todos abstractos.

### Caracter√≠sticas Clave
- üèóÔ∏è **Parcialmente implementadas**
- üîç **Contienen m√©todos abstractos y concretos**
- üß¨ **Relaci√≥n "es-un" con subclases**

### Ejemplo Completo
```java
public abstract class Figura {
    protected String color;
    
    public Figura(String color) {
        this.color = color;
    }
    
    // M√©todo abstracto (debe implementarse)
    public abstract double calcularArea();
    
    // M√©todo concreto (puede heredarse)
    public void mostrarColor() {
        System.out.println("Color: " + color);
    }
}

public class Circulo extends Figura {
    private double radio;
    
    public Circulo(String color, double radio) {
        super(color);
        this.radio = radio;
    }
    
    @Override
    public double calcularArea() {
        return Math.PI * radio * radio;
    }
}
```

---

## 13.2 Interfaces
Contratos que definen comportamientos sin implementaci√≥n (hasta Java 7).

### Evoluci√≥n de Interfaces
| Versi√≥n | Novedades                          |
|---------|------------------------------------|
| Java 7  | Solo m√©todos abstractos            |
| Java 8  | M√©todos `default` y `static`       |
| Java 9  | M√©todos `private` en interfaces    |

### Ejemplo Moderno
```java
public interface Reproducible {
    // M√©todo abstracto tradicional
    void reproducir();
    
    // M√©todo default (Java 8+)
    default void detener() {
        System.out.println("Deteniendo reproducci√≥n");
    }
    
    // M√©todo est√°tico (Java 8+)
    static String getFormato() {
        return "Formato multimedia";
    }
}

public class Video implements Reproducible {
    @Override
    public void reproducir() {
        System.out.println("Reproduciendo video...");
    }
}
```

---

## 13.3 Diferencias Clave
| Caracter√≠stica          | Clase Abstracta         | Interfaz                |
|-------------------------|-------------------------|-------------------------|
| **Instanciaci√≥n**       | No                      | No                      |
| **Atributos**           | S√≠ (cualquier visibilidad) | Solo constantes (`public static final`) |
| **M√©todos**             | Abstractos/concretos    | Todos abstractos (hasta Java 7) |
| **Herencia M√∫ltiple**   | No                      | S√≠                      |
| **Constructores**       | S√≠                      | No                      |
| **Relaci√≥n**            | "Es-un"                 | "Se-comporta-como"      |

---

## 13.4 Implementaci√≥n M√∫ltiple
Java permite implementar m√∫ltiples interfaces:

```java
interface Nadador {
    void nadar();
}

interface Volador {
    void volar();
}

class Pato implements Nadador, Volador {
    public void nadar() {
        System.out.println("Nadando en el lago");
    }
    
    public void volar() {
        System.out.println("Volando en formaci√≥n");
    }
}
```

---

## 13.5 M√©todos Default (Java 8+)
Permiten a√±adir implementaciones a interfaces sin romper c√≥digo existente.

### Caso de Uso
```java
public interface Logger {
    // M√©todo abstracto tradicional
    void log(String mensaje);
    
    // M√©todo default
    default void logError(String error) {
        log("[ERROR] " + error);
    }
}

public class ConsolaLogger implements Logger {
    @Override
    public void log(String mensaje) {
        System.out.println(mensaje);
    }
    // logError() heredado autom√°ticamente
}
```

---

## 13.6 Cu√°ndo Usar Cada Una

### Usa Clase Abstracta cuando:
- Existe relaci√≥n jer√°rquica clara ("es-un")
- Varias clases comparten c√≥digo com√∫n
- Necesitas atributos no constantes

### Usa Interfaz cuando:
- Clases no relacionadas necesitan mismo comportamiento
- Requieres herencia m√∫ltiple
- Quieres definir un contrato sin implementaci√≥n

---

## 13.7 Ejemplo Integrado
```java
// Jerarqu√≠a de empleados con capacidades especiales
abstract class Empleado {
    protected String nombre;
    
    public Empleado(String nombre) {
        this.nombre = nombre;
    }
    
    public abstract double calcularSalario();
}

interface Multiling√ºe {
    void hablarIdioma(String idioma);
}

interface Telefonista {
    void atenderLlamada();
}

class Recepcionista extends Empleado implements Multiling√ºe, Telefonista {
    public Recepcionista(String nombre) {
        super(nombre);
    }
    
    @Override
    public double calcularSalario() {
        return 1500.0;
    }
    
    @Override
    public void hablarIdioma(String idioma) {
        System.out.println(nombre + " habla " + idioma);
    }
    
    @Override
    public void atenderLlamada() {
        System.out.println(nombre + " atiende llamada");
    }
}
```

---

## üìå Puntos Clave
1. **Clases abstractas** = Implementaci√≥n parcial + herencia simple
2. **Interfaces** = Contratos + herencia m√∫ltiple
3. **`default`** permite evoluci√≥n de interfaces
4. **`abstract`** fuerza implementaci√≥n en subclases
5. **Composici√≥n** > Herencia en muchos casos

```mermaid
classDiagram
    class Empleado {
        <<abstract>>
        +String nombre
        +calcularSalario()* double
    }
    
    interface Multiling√ºe {
        <<interface>>
        +hablarIdioma(String) void
    }
    
    class Recepcionista {
        +calcularSalario() double
        +hablarIdioma(String) void
    }
    
    Empleado <|-- Recepcionista
    Multiling√ºe <|.. Recepcionista
```

> "Programa a interfaces, no a implementaciones" - Principio de Dise√±o SOLID
>
> ---
> # CAP√çTULO 14: COLECCIONES - ARRAYLIST, HASHMAP Y HASHSET

## üóÉÔ∏è Introducci√≥n a las Colecciones
Las colecciones en Java son estructuras de datos avanzadas que superan las limitaciones de los arrays tradicionales:

```java
import java.util.*; // Paquete necesario

// Ejemplo integrado
List<String> nombres = new ArrayList<>();
Set<Integer> numeros = new HashSet<>();
Map<String, Double> precios = new HashMap<>();
```

---

## 14.1 ArrayList - Listas Din√°micas
Estructura ordenada que permite duplicados y acceso por √≠ndice.

### Operaciones Esenciales
```java
ArrayList<String> frutas = new ArrayList<>();

// A√±adir elementos
frutas.add("Manzana");
frutas.add("Banana");
frutas.add(1, "Pera"); // Inserta en posici√≥n espec√≠fica

// Acceder
String primera = frutas.get(0); // "Manzana"

// Eliminar
frutas.remove("Banana");
frutas.remove(0); // Por √≠ndice

// Recorrer (for-each)
for (String fruta : frutas) {
    System.out.println(fruta);
}

// M√©todos √∫tiles
int tama√±o = frutas.size();
boolean vacia = frutas.isEmpty();
frutas.clear();
```

### Comparativa Array vs ArrayList
| Caracter√≠stica       | Array          | ArrayList       |
|----------------------|----------------|-----------------|
| Tama√±o               | Fijo           | Din√°mico        |
| Tipado               | Cualquier tipo | Solo objetos    |
| Rendimiento          | M√°s r√°pido     | Un poco m√°s lento |
| Flexibilidad         | Limitada       | Alta            |

---

## 14.2 HashSet - Conjuntos √önicos
Colecci√≥n que no permite duplicados, basada en tablas hash.

### Casos de Uso
- Eliminar duplicados de una lista
- Verificaci√≥n r√°pida de existencia

```java
HashSet<String> emails = new HashSet<>();

// A√±adir elementos
emails.add("user@example.com");
emails.add("admin@example.com");
emails.add("user@example.com"); // No se a√±ade

// Verificar existencia
if (emails.contains("admin@example.com")) {
    System.out.println("Email registrado");
}

// Convertir List a Set (elimina duplicados)
List<String> listaConDuplicados = Arrays.asList("A", "B", "A", "C");
Set<String> sinDuplicados = new HashSet<>(listaConDuplicados);
```

### Operaciones Matem√°ticas
```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5));

// Uni√≥n
Set<Integer> union = new HashSet<>(set1);
union.addAll(set2); // {1, 2, 3, 4, 5}

// Intersecci√≥n
Set<Integer> interseccion = new HashSet<>(set1);
interseccion.retainAll(set2); // {3}

// Diferencia
Set<Integer> diferencia = new HashSet<>(set1);
diferencia.removeAll(set2); // {1, 2}
```

---

## 14.3 HashMap - Diccionarios Clave-Valor
Estructura que mapea claves √∫nicas a valores.

### Ejemplo Completo
```java
HashMap<String, Integer> inventario = new HashMap<>();

// A√±adir/actualizar
inventario.put("Manzanas", 50);
inventario.put("Peras", 30);
inventario.put("Manzanas", 60); // Actualiza valor

// Acceder
int cantidad = inventario.get("Manzanas"); // 60

// Verificar clave
if (inventario.containsKey("Peras")) {
    System.out.println("Existen peras en inventario");
}

// Recorrer
for (Map.Entry<String, Integer> entry : inventario.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// M√©todos √∫tiles
inventario.remove("Peras");
int tama√±o = inventario.size();
```

### Caso Pr√°ctico: Contador de Palabras
```java
String texto = "hola mundo hola java mundo";
String[] palabras = texto.split(" ");

Map<String, Integer> contador = new HashMap<>();
for (String palabra : palabras) {
    contador.put(palabra, contador.getOrDefault(palabra, 0) + 1);
}
// Resultado: {hola=2, mundo=2, java=1}
```

---

## 14.4 Comparativa de Colecciones

| Caracter√≠stica       | ArrayList       | HashSet         | HashMap         |
|----------------------|-----------------|-----------------|-----------------|
| **Orden**            | Mantiene orden  | No ordenado     | No ordenado     |
| **Duplicados**       | Permite         | Rechaza         | Claves √∫nicas   |
| **Acceso**           | Por √≠ndice      | Solo existencia | Por clave       |
| **Rendimiento**      | O(1) acceso     | O(1) b√∫squeda   | O(1) b√∫squeda   |
| **Uso t√≠pico**       | Listas ordenadas| Conjuntos √∫nicos| Diccionarios    |

---

## 14.5 Buenas Pr√°cticas üõ†Ô∏è

### 1. Inicializaci√≥n con Capacidad
```java
// Para mejorar rendimiento en colecciones grandes
ArrayList<String> lista = new ArrayList<>(1000);
HashMap<String, Integer> mapa = new HashMap<>(500);
```

### 2. Iteraci√≥n Segura
```java
// Evitar ConcurrentModificationException
Iterator<String> it = lista.iterator();
while (it.hasNext()) {
    if (it.next().equals("eliminar")) {
        it.remove(); // Eliminaci√≥n segura
    }
}
```

### 3. Inmutabilidad
```java
// Colecciones inmodificables (Java 9+)
List<String> listaInmutable = List.of("A", "B", "C");
Set<Integer> setInmutable = Set.of(1, 2, 3);
Map<String, Integer> mapaInmutable = Map.of("A", 1, "B", 2);
```

### 4. Elecci√≥n de Implementaci√≥n
| Interfaz   | Implementaci√≥n Recomendada | Alternativas            |
|------------|---------------------------|-------------------------|
| List       | ArrayList                 | LinkedList, Vector      |
| Set        | HashSet                   | TreeSet, LinkedHashSet  |
| Map        | HashMap                   | TreeMap, LinkedHashMap  |

---

## üîÑ Ejemplo Integrado
```java
public class GestorContactos {
    private Map<String, Set<String>> agenda = new HashMap<>();
    
    public void agregarContacto(String nombre, String telefono) {
        agenda.putIfAbsent(nombre, new HashSet<>());
        agenda.get(nombre).add(telefono);
    }
    
    public Set<String> obtenerTelefonos(String nombre) {
        return agenda.getOrDefault(nombre, Collections.emptySet());
    }
    
    public void eliminarTelefono(String nombre, String telefono) {
        if (agenda.containsKey(nombre)) {
            agenda.get(nombre).remove(telefono);
            if (agenda.get(nombre).isEmpty()) {
                agenda.remove(nombre);
            }
        }
    }
}
```

---

## üìå Puntos Clave
1. **ArrayList**: Listas ordenadas y din√°micas
2. **HashSet**: Conjuntos de elementos √∫nicos
3. **HashMap**: Asociaciones clave-valor eficientes
4. **Gen√©ricos**: Especifican tipo de elementos (`<String, Integer>`)
5. **Interfaces**: Programar contra `List`, `Set`, `Map` en lugar de implementaciones

---
# CAP√çTULO 15: CLASES ANIDADAS Y AN√ìNIMAS

## üß© Introducci√≥n
Las clases anidadas y an√≥nimas son mecanismos avanzados de Java para:
- **Organizar c√≥digo relacionado** (clases anidadas)
- **Implementar interfaces r√°pidamente** (clases an√≥nimas)
- **Mejorar la encapsulaci√≥n**

```java
// Ejemplo base
class Externa {
    class Interna {} // Clase anidada
    
    void metodo() {
        Runnable r = new Runnable() { // Clase an√≥nima
            public void run() {
                System.out.println("Hola");
            }
        };
    }
}
```

---

## 15.1 Tipos de Clases Anidadas

### Tabla Comparativa
| Tipo                | Declaraci√≥n          | Acceso Externo | Instanciaci√≥n                  | Uso Com√∫n               |
|---------------------|----------------------|----------------|--------------------------------|-------------------------|
| **Clase Interna**   | `class Interna {}`   | Miembros no-static | `Externa.Interna obj = externa.new Interna()` | Componentes relacionados |
| **Clase Est√°tica**  | `static class Nested {}` | Solo miembros static | `Externa.Nested obj = new Externa.Nested()` | Utilidades helper |
| **Clase Local**     | Dentro de m√©todo     | Variables final/effectively final | Solo dentro del m√©todo | Implementaciones √∫nicas |
| **Clase An√≥nima**   | Sin nombre           | Variables final/effectively final | Al declararse | Eventos/listeners |

---

## 15.2 Clases Internas (Inner Classes)
Clases no est√°ticas declaradas dentro de otra clase.

### Ejemplo Pr√°ctico
```java
public class Electrodomestico {
    private String modelo;
    
    public Electrodomestico(String modelo) {
        this.modelo = modelo;
    }
    
    // Clase interna
    public class Motor {
        private int potencia;
        
        public Motor(int potencia) {
            this.potencia = potencia;
        }
        
        public void mostrarEspecificaciones() {
            System.out.println("Modelo: " + modelo + ", Potencia: " + potencia + "W");
            // Accede directamente al campo 'modelo' de la clase externa
        }
    }
}

// Uso
Electrodomestico lavadora = new Electrodomestico("XJ-2000");
Electrodomestico.Motor motor = lavadora.new Motor(1500);
motor.mostrarEspecificaciones();
```

### Casos de Uso
- **Patr√≥n Iterator**: Implementar iteradores personalizados
- **GUI**: Manejar eventos espec√≠ficos de componentes
- **Builder Pattern**: Construcci√≥n compleja de objetos

---

## 15.3 Clases An√≥nimas
Implementaciones "al vuelo" de interfaces o clases abstractas.

### Ejemplo con Interfaz
```java
interface Saludo {
    void saludar();
}

public class Main {
    public static void main(String[] args) {
        Saludo saludoEspa√±ol = new Saludo() {
            @Override
            public void saludar() {
                System.out.println("¬°Hola!");
            }
        };
        
        saludoEspa√±ol.saludar();
    }
}
```

### Ejemplo con Clase Abstracta
```java
abstract class Animal {
    abstract void hacerSonido();
}

public class Main {
    public static void main(String[] args) {
        Animal perro = new Animal() {
            @Override
            void hacerSonido() {
                System.out.println("Guau guau!");
            }
        };
        
        perro.hacerSonido();
    }
}
```

### Limitaciones
1. No pueden tener constructores
2. No pueden implementar m√∫ltiples interfaces
3. Solo pueden acceder a variables final/effectively final del √°mbito exterior

---

## 15.4 Diferencias Clave

| Caracter√≠stica      | Clase Interna       | Clase An√≥nima         |
|---------------------|---------------------|-----------------------|
| **Nombre**          | S√≠                  | No                    |
| **Reutilizaci√≥n**   | M√∫ltiples instancias| Uso √∫nico              |
| **Sintaxis**        | Declaraci√≥n completa| Implementaci√≥n concisa|
| **Acceso**          | Miembros externos   | Variables finales     |
| **Casos t√≠picos**   | Componentes complejos| Eventos/listeners     |

---

## 15.5 Buenas Pr√°cticas üõ†Ô∏è

### 1. Preferir Lambdas (Java 8+)
```java
// En lugar de:
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("Antiguo");
    }
};

// Mejor:
Runnable r = () -> System.out.println("Moderno");
```

### 2. Limitar Complejidad
```java
// ‚ùå Evitar (demasiado complejo)
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        // M√°s de 10 l√≠neas de c√≥digo
    }
});

// ‚úÖ Mejor: Crear clase interna con nombre
button.addActionListener(new ButtonListener());
```

### 3. Clases Est√°ticas para Utilidades
```java
public class Matem√°ticas {
    private Matem√°ticas() {} // No instanciable
    
    public static class Calculadora {
        public static int sumar(int a, int b) {
            return a + b;
        }
    }
}
```

### 4. Documentar Clases An√≥nimas Complejas
```java
Collections.sort(lista, new Comparator<String>() {
    /* Comparador que ignora may√∫sculas
       y ordena inversamente */
    @Override
    public int compare(String a, String b) {
        return b.compareToIgnoreCase(a);
    }
});
```

---

## üîÑ Ejemplo Integrado
```java
public class GUI {
    private List<Button> botones = new ArrayList<>();
    
    // Clase interna para manejar eventos
    private class ButtonHandler implements ActionListener {
        private final String accion;
        
        public ButtonHandler(String accion) {
            this.accion = accion;
        }
        
        @Override
        public void actionPerformed(ActionEvent e) {
            System.out.println("Ejecutando: " + accion);
        }
    }
    
    public void agregarBoton(String texto, String accion) {
        Button btn = new Button(texto);
        btn.addActionListener(new ButtonHandler(accion));
        botones.add(btn);
    }
    
    // Uso de clase an√≥nima para un caso especial
    public void agregarBotonSalir() {
        Button btn = new Button("Salir");
        btn.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.exit(0);
            }
        });
        botones.add(btn);
    }
}
```

---

## üìå Puntos Clave
1. **Clases internas** = Organizaci√≥n + acceso a miembros externos
2. **Clases an√≥nimas** = Implementaci√≥n r√°pida + √∫nica
3. **`final`** variables requeridas para acceso en clases an√≥nimas
4. **Lambdas** > Clases an√≥nimas para interfaces funcionales
5. **Documentar** cuando la l√≥gica es compleja

> "Las clases anidadas deben usarse para representar relaciones has-a (tiene-un) fuertemente acopladas" - Joshua Bloch
>
> ---
> # CAP√çTULO 16: FLUJOS DE ENTRADA/SALIDA (I/O) EN JAVA

## üåä Introducci√≥n a los Streams
Los flujos de entrada/salida (I/O) en Java permiten leer y escribir datos desde/hacia diversas fuentes:

```java
import java.io.*;

// Ejemplo b√°sico
try (InputStream in = new FileInputStream("entrada.txt");
     OutputStream out = new FileOutputStream("salida.txt")) {
    int dato;
    while ((dato = in.read()) != -1) {
        out.write(dato);
    }
}
```

---

## 16.1 Jerarqu√≠a B√°sica de I/O

### Diagrama de Clases
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   InputStream    ‚îÇ       ‚îÇ   OutputStream   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  FileInputStream  ‚îÇ      ‚îÇ FileOutputStream ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 16.2 InputStream - Lectura de Bytes

### M√©todos Principales
| M√©todo               | Descripci√≥n                              |
|----------------------|------------------------------------------|
| `int read()`         | Lee 1 byte (0-255), -1 si fin de archivo |
| `int read(byte[] b)` | Lee bytes a un buffer                    |
| `void close()`       | Libera recursos                          |

### Ejemplo: Lectura de Archivo
```java
public class LectorBytes {
    public static void main(String[] args) {
        try (InputStream is = new FileInputStream("datos.bin")) {
            byte[] buffer = new byte[1024];
            int bytesLeidos;
            
            while ((bytesLeidos = is.read(buffer)) != -1) {
                procesarBytes(buffer, bytesLeidos);
            }
        } catch (IOException e) {
            System.err.println("Error: " + e.getMessage());
        }
    }
    
    private static void procesarBytes(byte[] datos, int longitud) {
        // Implementaci√≥n de procesamiento
    }
}
```

---

## 16.3 OutputStream - Escritura de Bytes

### M√©todos Principales
| M√©todo                | Descripci√≥n                      |
|-----------------------|----------------------------------|
| `void write(int b)`   | Escribe 1 byte                   |
| `void write(byte[] b)`| Escribe array de bytes           |
| `void flush()`        | Fuerza descarga del buffer       |
| `void close()`        | Libera recursos                  |

### Ejemplo: Escritura de Archivo
```java
public class EscritorBytes {
    public static void main(String[] args) {
        String datos = "Ejemplo de datos";
        
        try (OutputStream os = new FileOutputStream("salida.bin")) {
            os.write(datos.getBytes());
            os.flush(); // Asegura que los datos se escriban
        } catch (IOException e) {
            System.err.println("Error: " + e.getMessage());
        }
    }
}
```

---

## 16.4 Buffered I/O - Mejorando el Rendimiento

### Comparaci√≥n de Rendimiento
| Operaci√≥n            | Sin Buffer | Con Buffer |
|----------------------|------------|------------|
| Tiempo lectura 1MB   | 1200 ms    | 150 ms     |
| Tiempo escritura 1MB | 800 ms     | 100 ms     |

### Ejemplo con Buffer
```java
// Lectura bufferizada
try (BufferedInputStream bis = new BufferedInputStream(
        new FileInputStream("grande.dat"))) {
    byte[] buffer = new byte[4096];
    int bytesLeidos;
    
    while ((bytesLeidos = bis.read(buffer)) != -1) {
        // Procesamiento
    }
}

// Escritura bufferizada
try (BufferedOutputStream bos = new BufferedOutputStream(
        new FileOutputStream("copia.dat"))) {
    byte[] datos = obtenerDatos();
    bos.write(datos);
}
```

---

## 16.5 try-with-resources (Java 7+)
Estructura que garantiza el cierre autom√°tico de recursos.

### Beneficios
- ‚úÖ Cierre autom√°tico
- ‚úÖ M√°s legible
- ‚úÖ Manejo seguro de excepciones

### Sintaxis
```java
try (Recurso1 r1 = new Recurso1();
     Recurso2 r2 = new Recurso2()) {
    // Usar recursos
} catch (IOException e) {
    // Manejar error
} // Los recursos se cierran autom√°ticamente
```

---

## 16.6 Comparativa de Flujos

| Caracter√≠stica       | InputStream         | OutputStream        |
|----------------------|---------------------|---------------------|
| **Prop√≥sito**        | Lectura de bytes    | Escritura de bytes  |
| **Fuente/Destino**   | Archivos, red, etc. | Archivos, red, etc. |
| **Bufferizado**      | Recomendado         | Recomendado         |
| **M√©todo clave**     | read()              | write()             |
| **Cierre**           | Obligatorio         | Obligatorio         |

---

## 16.7 Buenas Pr√°cticas üõ°Ô∏è

### 1. Tama√±o de Buffer √ìptimo
```java
// Tama√±o recomendado: m√∫ltiplo de 4096 (tama√±o de p√°gina com√∫n)
byte[] buffer = new byte[8192];
```

### 2. Manejo Correcto de Excepciones
```java
try (InputStream in = new FileInputStream("datos")) {
    // Operaciones
} catch (FileNotFoundException e) {
    System.err.println("Archivo no encontrado");
} catch (IOException e) {
    System.err.println("Error de E/S: " + e.getMessage());
}
```

### 3. Cierre en Orden Inverso
```java
// Correcto:
try (OutputStream os = new FileOutputStream("a");
     InputStream is = new FileInputStream("b")) {
    // Usar primero 'is', luego 'os'
}

// El cierre se hace autom√°ticamente en orden inverso (os -> is)
```

### 4. Verificaci√≥n de Recursos
```java
Path ruta = Paths.get("archivo.txt");
if (Files.exists(ruta) && Files.isReadable(ruta)) {
    try (InputStream in = Files.newInputStream(ruta)) {
        // Lectura segura
    }
}
```

---

## üîÑ Ejemplo Integrado: Copiador de Archivos
```java
public class CopiadorArchivos {
    public static void copiar(String origen, String destino) throws IOException {
        // Verificar archivos
        File archivoOrigen = new File(origen);
        if (!archivoOrigen.exists()) {
            throw new FileNotFoundException(origen + " no existe");
        }
        
        // Copia con buffer
        try (InputStream in = new BufferedInputStream(
                new FileInputStream(origen));
             OutputStream out = new BufferedOutputStream(
                new FileOutputStream(destino))) {
            
            byte[] buffer = new byte[8192];
            int bytesLeidos;
            
            while ((bytesLeidos = in.read(buffer)) != -1) {
                out.write(buffer, 0, bytesLeidos);
            }
            
            System.out.println("Copia completada: " + 
                archivoOrigen.length() + " bytes copiados");
        }
    }
}
```

---

## üìå Puntos Clave
1. **InputStream/OutputStream** son clases base para E/S binaria
2. **Buffered I/O** mejora significativamente el rendimiento
3. **try-with-resources** garantiza el cierre adecuado
4. **Flush** asegura que los datos se escriban f√≠sicamente
5. **Manejo de errores** es cr√≠tico en operaciones de E/S

---
# CAP√çTULO 17: LECTURA Y ESCRITURA DE ARCHIVOS DE TEXTO

## üìñ Introducci√≥n a FileReader y FileWriter
Clases especializadas para manejar archivos de texto (caracteres) en Java:

```java
import java.io.*;

// Ejemplo b√°sico
try (FileReader reader = new FileReader("entrada.txt");
     FileWriter writer = new FileWriter("salida.txt")) {
    int caracter;
    while ((caracter = reader.read()) != -1) {
        writer.write(caracter);
    }
}
```

---

## 17.1 FileReader - Lectura de Texto

### M√©todos Principales
| M√©todo               | Descripci√≥n                              |
|----------------------|------------------------------------------|
| `int read()`         | Lee 1 car√°cter (0-65535), -1 si EOF      |
| `int read(char[] c)` | Lee caracteres a un buffer               |
| `void close()`       | Libera recursos                          |

### Ejemplo: Lectura Eficiente
```java
public class LectorTexto {
    public static void main(String[] args) {
        char[] buffer = new char[1024]; // Buffer de 1KB
        int charsLeidos;
        
        try (FileReader fr = new FileReader("documento.txt")) {
            while ((charsLeidos = fr.read(buffer)) != -1) {
                procesarTexto(buffer, charsLeidos);
            }
        } catch (IOException e) {
            System.err.println("Error lectura: " + e.getMessage());
        }
    }
    
    private static void procesarTexto(char[] texto, int longitud) {
        System.out.println(new String(texto, 0, longitud));
    }
}
```

---

## 17.2 FileWriter - Escritura de Texto

### M√©todos Clave
| M√©todo                | Descripci√≥n                      |
|-----------------------|----------------------------------|
| `void write(int c)`   | Escribe 1 car√°cter               |
| `void write(String s)`| Escribe cadena completa          |
| `void write(char[] c)`| Escribe array de caracteres      |
| `void flush()`        | Fuerza escritura inmediata       |
| `void close()`        | Cierra el flujo                  |

### Ejemplo: Escritura con Append
```java
public class RegistroLog {
    public static void a√±adirEntrada(String mensaje) {
        try (FileWriter fw = new FileWriter("app.log", true)) { // Modo append
            fw.write(LocalDateTime.now() + ": " + mensaje + "\n");
            fw.flush(); // Asegura escritura inmediata
        } catch (IOException e) {
            System.err.println("Error en log: " + e.getMessage());
        }
    }
}
```

---

## 17.3 Buffered I/O para Texto

### Comparaci√≥n de Rendimiento
| Operaci√≥n            | FileReader/Writer | BufferedReader/Writer |
|----------------------|-------------------|-----------------------|
| Tiempo lectura 1MB   | 450 ms            | 80 ms                 |
| Tiempo escritura 1MB | 380 ms            | 70 ms                 |

### Ejemplo Optimizado
```java
// Lectura bufferizada
try (BufferedReader br = new BufferedReader(new FileReader("grande.txt"))) {
    String linea;
    while ((linea = br.readLine()) != null) { // Lee por l√≠neas
        System.out.println(linea);
    }
}

// Escritura bufferizada
try (BufferedWriter bw = new BufferedWriter(new FileWriter("salida.txt"))) {
    bw.write("L√≠nea 1");
    bw.newLine(); // Salto de l√≠nea multiplataforma
    bw.write("L√≠nea 2");
}
```

---

## 17.4 Manejo de Codificaciones

### Problema Com√∫n
```java
// ‚ùå Usa codificaci√≥n por defecto (puede variar entre sistemas)
FileReader fr = new FileReader("texto.txt");
```

### Soluci√≥n Recomendada (Java 11+)
```java
// ‚úÖ Especificar codificaci√≥n expl√≠cita (UTF-8 recomendado)
try (BufferedReader br = Files.newBufferedReader(
        Path.of("texto.txt"), StandardCharsets.UTF_8)) {
    // Lectura con codificaci√≥n controlada
}
```

### Alternativa para versiones anteriores
```java
try (InputStreamReader isr = new InputStreamReader(
        new FileInputStream("texto.txt"), "UTF-8")) {
    // Lectura con codificaci√≥n espec√≠fica
}
```

---

## 17.5 Buenas Pr√°cticas üõ°Ô∏è

### 1. Validaci√≥n de Archivos
```java
Path ruta = Paths.get("datos.txt");
if (!Files.exists(ruta)) {
    throw new FileNotFoundException("Archivo no encontrado");
}
if (!Files.isReadable(ruta)) {
    throw new IOException("Sin permisos de lectura");
}
```

### 2. Manejo de Recursos
```java
// ‚ùå Riesgo: recurso no cerrado
FileWriter fw = new FileWriter("temp.txt");
fw.write("datos"); // Si hay error, no se cierra

// ‚úÖ Correcto (try-with-resources)
try (FileWriter fw = new FileWriter("temp.txt")) {
    fw.write("datos");
}
```

### 3. Bufferizaci√≥n Obligatoria
> "Siempre usa buffers para archivos > 1KB"

### 4. M√©todos √ötiles de Files (Java 7+)
```java
// Lectura simple
String contenido = Files.readString(Path.of("texto.txt"));

// Escritura simple
Files.writeString(Path.of("salida.txt"), "Contenido");
```

---

## üîÑ Ejemplo Integrado: Procesador de Texto
```java
public class ProcesadorArchivos {
    public static void copiarConFiltro(String origen, String destino, 
            Predicate<String> filtro) throws IOException {
        
        try (BufferedReader br = Files.newBufferedReader(Path.of(origen));
             BufferedWriter bw = Files.newBufferedWriter(Path.of(destino))) {
            
            String linea;
            while ((linea = br.readLine()) != null) {
                if (filtro.test(linea)) {
                    bw.write(linea);
                    bw.newLine();
                }
            }
        }
    }
    
    public static void main(String[] args) {
        try {
            // Copia solo l√≠neas que contienen "ERROR"
            copiarConFiltro("app.log", "errores.log", 
                linea -> linea.contains("ERROR"));
        } catch (IOException e) {
            System.err.println("Error procesando archivos: " + e.getMessage());
        }
    }
}
```

---

## üìå Puntos Clave
1. **FileReader/Writer** para texto simple
2. **BufferedReader/Writer** para mejor rendimiento
3. **try-with-resources** garantiza cierre adecuado
4. **Codificaci√≥n expl√≠cita** evita problemas entre plataformas
5. **Files helper** (Java 7+) simplifica operaciones comunes

---
# CAP√çTULO 18: BUFFEREDREADER Y BUFFEREDWRITER PARA DATOS MASIVOS

## üöÄ Introducci√≥n a la E/S Bufferizada
Los flujos bufferizados optimizan el manejo de grandes vol√∫menes de texto mediante el uso de memoria intermedia:

```java
// Ejemplo base de alta eficiencia
try (BufferedReader br = new BufferedReader(new FileReader("bigdata.txt"));
     BufferedWriter bw = new BufferedWriter(new FileWriter("resultados.txt"))) {
    String linea;
    while ((linea = br.readLine()) != null) {
        bw.write(procesarLinea(linea));
        bw.newLine();
    }
}
```

---

## 18.1 Beneficios del Buffering

### Comparaci√≥n de Rendimiento
| Operaci√≥n            | Sin Buffer | Con Buffer | Mejora |
|----------------------|------------|------------|--------|
| Lectura 1GB (l√≠neas) | 42 seg     | 3.8 seg    | 11x    |
| Escritura 1GB        | 38 seg     | 4.1 seg    | 9x     |

### Mecanismo de Operaci√≥n
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   Peque√±os   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Disco     ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  Buffer     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   Bloques    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚ñ≤
                                   ‚îÇ Car√°cter a
                                   ‚îÇ car√°cter
                                   ‚ñº
                             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                             ‚îÇ  Programa   ‚îÇ
                             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 18.2 BufferedReader - Lectura Optimizada

### M√©todos Clave
| M√©todo               | Descripci√≥n                              |
|----------------------|------------------------------------------|
| `String readLine()`  | Lee l√≠nea completa (excluye \n o \r\n)   |
| `int read()`         | Lee 1 car√°cter (√∫til para control fino)   |
| `long skip(long n)`  | Salta n caracteres                       |

### Ejemplo: Procesamiento de Logs
```java
public class AnalizadorLogs {
    public static Map<String, Integer> contarErrores(String archivo) throws IOException {
        Map<String, Integer> conteo = new HashMap<>();
        
        try (BufferedReader br = new BufferedReader(new FileReader(archivo))) {
            String linea;
            while ((linea = br.readLine()) != null) {
                if (linea.contains("ERROR")) {
                    String tipo = extraerTipoError(linea);
                    conteo.put(tipo, conteo.getOrDefault(tipo, 0) + 1);
                }
            }
        }
        return conteo;
    }
    
    private static String extraerTipoError(String linea) {
        // Implementaci√≥n de extracci√≥n
    }
}
```

---

## 18.3 BufferedWriter - Escritura Eficiente

### M√©todos Esenciales
| M√©todo                | Descripci√≥n                              |
|-----------------------|------------------------------------------|
| `void write(String)`  | Escribe cadena completa                  |
| `void newLine()`      | Inserta salto de l√≠nea multiplataforma   |
| `void flush()`        | Descarga buffer a disco                  |

### Ejemplo: Generaci√≥n de Reportes
```java
public class GeneradorReportes {
    public static void generarReporte(List<String> datos, String archivoSalida) throws IOException {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(archivoSalida))) {
            bw.write("REPORTE DIARIO");
            bw.newLine();
            bw.write("=================");
            bw.newLine();
            
            for (String dato : datos) {
                bw.write(formatearDato(dato));
                bw.newLine();
            }
            
            bw.flush(); // Asegura escritura inmediata
        }
    }
}
```

---

## 18.4 T√©cnicas Avanzadas

### 1. Tama√±o de Buffer Personalizado
```java
// Buffer de 64KB (por defecto es 8KB)
BufferedReader br = new BufferedReader(new FileReader("data.txt"), 65536);
```

### 2. Procesamiento en Paralelo (Java 8+)
```java
try (Stream<String> lineas = Files.lines(Paths.get("bigfile.txt"))) {
    lineas.parallel()
          .filter(linea -> linea.contains("WARNING"))
          .forEach(System.out::println);
}
```

### 3. Lectura/escritura con Codificaci√≥n Espec√≠fica
```java
BufferedReader br = new BufferedReader(
    new InputStreamReader(
        new FileInputStream("datos.txt"), 
        StandardCharsets.ISO_8859_1));
```

---

## 18.5 Patrones Comunes

### 1. Filtrado de L√≠neas
```java
try (BufferedReader br = /*...*/;
     BufferedWriter bw = /*...*/) {
    br.lines()
      .filter(linea -> !linea.startsWith("#")) // Ignora comentarios
      .map(String::toUpperCase)
      .forEach(linea -> {
          try { bw.write(linea); bw.newLine(); } 
          catch (IOException e) { /* manejo */ }
      });
}
```

### 2. Procesamiento por Bloques
```java
char[] buffer = new char[8192];
int charsLeidos;
while ((charsLeidos = br.read(buffer)) != -1) {
    // Procesar bloque de caracteres
    bw.write(buffer, 0, charsLeidos);
}
```

---

## 18.6 Buenas Pr√°cticas üõ°Ô∏è

### 1. Buffer Size Optimization
```java
// Para archivos >100MB usar buffer de 64KB-256KB
int bufferSize = 128 * 1024; // 128KB
BufferedReader br = new BufferedReader(new FileReader("huge.txt"), bufferSize);
```

### 2. Manejo de Recursos Compuestos
```java
try (InputStream fis = new FileInputStream("data.gz");
     GZIPInputStream gzis = new GZIPInputStream(fis);
     InputStreamReader isr = new InputStreamReader(gzis);
     BufferedReader br = new BufferedReader(isr)) {
    // Lectura de archivo comprimido
}
```

### 3. Validaci√≥n de L√≠neas Largas
```java
// Prevenir OutOfMemoryError con l√≠neas muy largas
br.lines().forEach(linea -> {
    if (linea.length() > MAX_LONGITUD) {
        throw new IOException("L√≠nea demasiado larga");
    }
    // Procesamiento
});
```

---

## üîÑ Ejemplo Integrado: Procesador de Datos Masivos
```java
public class ProcesadorCSV {
    private static final int BUFFER_SIZE = 131072; // 128KB
    
    public void procesarArchivo(String entrada, String salida) throws IOException {
        try (BufferedReader br = new BufferedReader(new FileReader(entrada), BUFFER_SIZE);
             BufferedWriter bw = new BufferedWriter(new FileWriter(salida), BUFFER_SIZE)) {
            
            // Cabecera
            String cabecera = br.readLine();
            bw.write(transformarCabecera(cabecera));
            bw.newLine();
            
            // Procesamiento paralelo de l√≠neas
            br.lines()
              .parallel()
              .map(this::procesarLinea)
              .sequential() // Vuelve a secuencial para escritura ordenada
              .forEach(linea -> {
                  try { 
                      bw.write(linea);
                      bw.newLine(); 
                  } catch (IOException e) {
                      throw new UncheckedIOException(e);
                  }
              });
        }
    }
    
    private String transformarCabecera(String cabecera) {
        // L√≥gica de transformaci√≥n
    }
    
    private String procesarLinea(String linea) {
        // L√≥gica de procesamiento
    }
}
```

---

## üìå Puntos Clave
1. **Buffering** reduce accesos a disco (√ó10 rendimiento)
2. **readLine()** ideal para procesamiento por l√≠neas
3. **newLine()** asegura portabilidad entre SO
4. **try-with-resources** manejo seguro de recursos
5. **Tama√±o de buffer** ajustable para optimizaci√≥n

---
# CAP√çTULO 19: MANEJO DE ARCHIVOS BINARIOS EN JAVA

## üî¢ Introducci√≥n a los Archivos Binarios
Los archivos binarios almacenan datos en su formato nativo (bytes), ideal para:
- **Eficiencia**: Menor tama√±o que texto
- **Precisi√≥n**: Sin p√©rdidas en conversiones
- **Rendimiento**: Lectura/escritura m√°s r√°pida

```java
// Ejemplo b√°sico
try (DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.bin"))) {
    dos.writeInt(42);
    dos.writeDouble(3.14159);
    dos.writeUTF("Hola binario");
}
```

---

## 19.1 Clases Principales para Binarios

### DataOutputStream
| M√©todo               | Tipo de Dato | Tama√±o (bytes) |
|----------------------|--------------|----------------|
| `writeBoolean()`     | boolean      | 1              |
| `writeByte()`        | byte         | 1              |
| `writeChar()`        | char         | 2              |
| `writeShort()`       | short        | 2              |
| `writeInt()`         | int          | 4              |
| `writeLong()`        | long         | 8              |
| `writeFloat()`       | float        | 4              |
| `writeDouble()`      | double       | 8              |
| `writeUTF()`         | String       | Variable       |

### DataInputStream
Proporciona m√©todos equivalentes para lectura (`readInt()`, `readDouble()`, etc.)

---

## 19.2 Escritura de Datos Binarios

### Ejemplo Completo
```java
public class EscritorBinario {
    public static void escribirDatos(String archivo) throws IOException {
        try (DataOutputStream dos = new DataOutputStream(
                new BufferedOutputStream(
                    new FileOutputStream(archivo)))) {
            
            // Escribir datos de ejemplo
            dos.writeInt(150);                    // 4 bytes
            dos.writeDouble(12.99);               // 8 bytes
            dos.writeBoolean(true);               // 1 byte
            dos.writeUTF("Ejemplo de texto");     // Longitud + contenido
            
            // Buffer se escribe autom√°ticamente al cerrar
        }
    }
}
```

**Consideraciones:**
- Usar `BufferedOutputStream` para mejor rendimiento
- El orden de escritura determina el orden de lectura
- `writeUTF()` escribe primero la longitud (2 bytes) + contenido

---

## 19.3 Lectura de Datos Binarios

### Ejemplo con Validaci√≥n
```java
public class LectorBinario {
    public static void leerDatos(String archivo) throws IOException {
        try (DataInputStream dis = new DataInputStream(
                new BufferedInputStream(
                    new FileInputStream(archivo)))) {
            
            // Leer en el MISMO orden que se escribieron
            int entero = dis.readInt();
            double decimal = dis.readDouble();
            boolean flag = dis.readBoolean();
            String texto = dis.readUTF();
            
            System.out.printf("""
                Entero: %d
                Decimal: %.2f
                Booleano: %b
                Texto: %s%n""", entero, decimal, flag, texto);
            
        } catch (EOFException e) {
            System.err.println("Fin de archivo inesperado");
        }
    }
}
```

**Manejo de Errores:**
- `EOFException`: Fin de archivo prematuro
- `IOException`: Problemas generales de E/S

---

## 19.4 Estructuras Complejas

### Ejemplo: Array de Objetos
```java
public class Registro implements Serializable {
    private int id;
    private String nombre;
    private double precio;
    
    // Constructor, getters, setters...
}

public class AlmacenBinario {
    public static void guardarRegistros(Registro[] registros, String archivo) 
            throws IOException {
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream(archivo))) {
            oos.writeInt(registros.length);  // Guardar cantidad
            for (Registro r : registros) {
                oos.writeObject(r);          // Guardar cada objeto
            }
        }
    }
    
    public static Registro[] cargarRegistros(String archivo) 
            throws IOException, ClassNotFoundException {
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream(archivo))) {
            int cantidad = ois.readInt();
            Registro[] registros = new Registro[cantidad];
            for (int i = 0; i < cantidad; i++) {
                registros[i] = (Registro) ois.readObject();
            }
            return registros;
        }
    }
}
```

---

## 19.5 Buenas Pr√°cticas üõ°Ô∏è

### 1. Marcas de Archivo
```java
// Al escribir
dos.writeInt(0x4A415641); // "JAVA" en hex

// Al leer
int marca = dis.readInt();
if (marca != 0x4A415641) {
    throw new IOException("Formato inv√°lido");
}
```

### 2. Bufferizaci√≥n Obligatoria
```java
// ‚ùå Ineficiente
DataInputStream dis = new DataInputStream(new FileInputStream("data.bin"));

// ‚úÖ Correcto
DataInputStream dis = new DataInputStream(
    new BufferedInputStream(
        new FileInputStream("data.bin")));
```

### 3. Versi√≥n de Estructuras
```java
// Incluir versi√≥n en el archivo
dos.writeInt(2); // Versi√≥n 2 del formato

// Al leer
int version = dis.readInt();
if (version > ULTIMA_VERSION) {
    throw new IOException("Versi√≥n no soportada");
}
```

### 4. Validaci√≥n de Integridad
```java
// Al final del archivo
dos.writeLong(calcularChecksum(datos));

// Al leer
long checksum = dis.readLong();
if (checksum != calcularChecksum(datosLeidos)) {
    throw new IOException("Datos corruptos");
}
```

---

## üîÑ Ejemplo Integrado: Base de Datos Simple
```java
public class MiniDB {
    private static final int BUFFER_SIZE = 8192;
    private static final long MAGIC_NUMBER = 0xCAFEBABEL;
    
    public static void guardar(Map<Integer, Producto> inventario, String archivo) 
            throws IOException {
        try (DataOutputStream dos = new DataOutputStream(
                new BufferedOutputStream(
                    new FileOutputStream(archivo), BUFFER_SIZE))) {
            
            // Cabecera
            dos.writeLong(MAGIC_NUMBER);
            dos.writeInt(1); // Versi√≥n formato
            
            // Datos
            dos.writeInt(inventario.size());
            for (Producto p : inventario.values()) {
                dos.writeInt(p.getId());
                dos.writeUTF(p.getNombre());
                dos.writeDouble(p.getPrecio());
                dos.writeInt(p.getStock());
            }
            
            // Checksum
            dos.writeLong(calcularChecksum(inventario));
        }
    }
    
    public static Map<Integer, Producto> cargar(String archivo) 
            throws IOException, DBException {
        Map<Integer, Producto> inventario = new HashMap<>();
        
        try (DataInputStream dis = new DataInputStream(
                new BufferedInputStream(
                    new FileInputStream(archivo), BUFFER_SIZE))) {
            
            // Validar cabecera
            if (dis.readLong() != MAGIC_NUMBER) {
                throw new DBException("Archivo no v√°lido");
            }
            
            int version = dis.readInt();
            if (version != 1) {
                throw new DBException("Versi√≥n no soportada: " + version);
            }
            
            // Leer datos
            int cantidad = dis.readInt();
            for (int i = 0; i < cantidad; i++) {
                int id = dis.readInt();
                String nombre = dis.readUTF();
                double precio = dis.readDouble();
                int stock = dis.readInt();
                
                inventario.put(id, new Producto(id, nombre, precio, stock));
            }
            
            // Validar checksum
            long checksum = dis.readLong();
            if (checksum != calcularChecksum(inventario)) {
                throw new DBException("Datos corruptos");
            }
        }
        
        return inventario;
    }
    
    private static long calcularChecksum(Map<Integer, Producto> datos) {
        // Implementaci√≥n de checksum
    }
}
```

---

## üìå Puntos Clave
1. **DataInputStream/DataOutputStream** para tipos primitivos
2. **ObjectInputStream/ObjectOutputStream** para objetos serializables
3. **Orden de lectura = Orden de escritura** (cr√≠tico)
4. **Bufferizaci√≥n** mejora rendimiento en archivos grandes
5. **Marcas/checksums** para validar integridad

---
# CAP√çTULO 20: SERIALIZACI√ìN DE OBJETOS EN JAVA

## üßä Introducci√≥n a la Serializaci√≥n
La serializaci√≥n permite convertir objetos Java en secuencias de bytes para:
- Almacenamiento persistente
- Transmisi√≥n por red
- Comunicaci√≥n entre JVMs

```java
import java.io.*;

// Clase serializable b√°sica
public class Persona implements Serializable {
    private static final long serialVersionUID = 1L;
    private String nombre;
    private int edad;
    
    // Constructor, getters, setters...
}
```

---

## 20.1 Fundamentos de Serializaci√≥n

### ¬øQu√© se serializa?
- Todos los campos no-transient
- La jerarqu√≠a completa del objeto
- Referencias a otros objetos (si son serializables)

### Ejemplo B√°sico
```java
public class Serializador {
    public static void serializar(Object obj, String archivo) throws IOException {
        try (ObjectOutputStream oos = new ObjectOutputStream(
                new FileOutputStream(archivo))) {
            oos.writeObject(obj);
        }
    }
    
    public static Object deserializar(String archivo) 
            throws IOException, ClassNotFoundException {
        try (ObjectInputStream ois = new ObjectInputStream(
                new FileInputStream(archivo))) {
            return ois.readObject();
        }
    }
}
```

---

## 20.2 Control de la Serializaci√≥n

### Campos Transient
```java
public class Configuracion implements Serializable {
    private static final long serialVersionUID = 2L;
    
    private String usuario;
    private transient String password; // No se serializa
    private transient Connection conexionDB; // Recurso no serializable
}
```

### M√©todos Especiales
```java
private void writeObject(ObjectOutputStream out) throws IOException {
    out.defaultWriteObject(); // Serializaci√≥n est√°ndar
    out.writeUTF(password.replaceAll(".", "*")); // Ofuscaci√≥n
}

private void readObject(ObjectInputStream in) 
        throws IOException, ClassNotFoundException {
    in.defaultReadObject(); // Deserializaci√≥n est√°ndar
    this.password = in.readUTF(); // Recuperar password ofuscado
}
```

---

## 20.3 serialVersionUID

### Importancia
- Identificador de versi√≥n de la clase
- Previene errores de incompatibilidad
- Debe actualizarse cuando cambia la estructura

### Generaci√≥n Recomendada
```java
// Usar 'serialver' tool de JDK o IDE
private static final long serialVersionUID = -6470090944414208496L;
```

### Escenarios
| Cambio en Clase          | Compatible con UID original? |
|--------------------------|------------------------------|
| Campos transient         | S√≠                           |
| Nuevos campos            | No (InvalidClassException)   |
| Cambio tipo de campo     | No                           |
| Cambio nombre campo      | No                           |

---

## 20.4 Serializaci√≥n Avanzada

### 1. Serializaci√≥n de Colecciones
```java
List<Persona> agenda = new ArrayList<>();
// ... llenar lista

// Serializar toda la colecci√≥n
try (ObjectOutputStream oos = /*...*/) {
    oos.writeObject(agenda);
}
```

### 2. Patr√≥n Singleton con Serializaci√≥n
```java
public class Singleton implements Serializable {
    private static final long serialVersionUID = 1L;
    private static final Singleton INSTANCE = new Singleton();
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        return INSTANCE;
    }
    
    // Mantener singleton despu√©s de deserializaci√≥n
    protected Object readResolve() {
        return INSTANCE;
    }
}
```

### 3. Serializaci√≥n Externa (Externalizable)
```java
public class Producto implements Externalizable {
    private String nombre;
    private double precio;
    
    // Constructor p√∫blico sin args requerido
    public Producto() {}
    
    @Override
    public void writeExternal(ObjectOutput out) throws IOException {
        out.writeUTF(nombre);
        out.writeDouble(precio);
    }
    
    @Override
    public void readExternal(ObjectInput in) 
            throws IOException, ClassNotFoundException {
        this.nombre = in.readUTF();
        this.precio = in.readDouble();
    }
}
```

---

## 20.5 Buenas Pr√°cticas üõ°Ô∏è

### 1. Validaci√≥n de Seguridad
```java
// Antes de deserializar
Path path = Paths.get("datos.ser");
if (Files.size(path) > MAX_TAMANO_PERMITIDO) {
    throw new SecurityException("Archivo demasiado grande");
}
```

### 2. Serializaci√≥n Selectiva
```java
public class Factura implements Serializable {
    private transient List<LineaDetalle> lineas;
    
    private void writeObject(ObjectOutputStream out) throws IOException {
        out.defaultWriteObject();
        out.writeInt(lineas.size());
        for (LineaDetalle ld : lineas) {
            out.writeObject(ld.getProducto());
            out.writeInt(ld.getCantidad());
        }
    }
    
    private void readObject(ObjectInputStream in) 
            throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        int cantidad = in.readInt();
        this.lineas = new ArrayList<>();
        for (int i = 0; i < cantidad; i++) {
            Producto p = (Producto) in.readObject();
            int cant = in.readInt();
            lineas.add(new LineaDetalle(p, cant));
        }
    }
}
```

### 3. Alternativas Modernas
```java
// Considerar JSON para APIs web
ObjectMapper mapper = new XMLMapper(); // o JSONMapper
String xml = mapper.writeValueAsString(objeto);

// O protobuf para alto rendimiento
ProductoProto producto = ProductoProto.newBuilder()
    .setNombre("Ejemplo")
    .setPrecio(9.99)
    .build();
```

---

## üîÑ Ejemplo Integrado: Sistema de Backup
```java
public class SistemaBackup {
    private static final String BACKUP_FILE = "backup.ser";
    
    public static void guardarEstado(Aplicacion app) throws IOException {
        // Validar datos antes de serializar
        if (!app.estadoValido()) {
            throw new IllegalStateException("Estado inv√°lido para backup");
        }
        
        // Serializaci√≥n segura
        Path tempFile = Files.createTempFile("backup", ".tmp");
        try (ObjectOutputStream oos = new ObjectOutputStream(
                Files.newOutputStream(tempFile))) {
            oos.writeObject(app);
        }
        
        // Reemplazar archivo antiguo at√≥micamente
        Files.move(tempFile, Paths.get(BACKUP_FILE), 
            StandardCopyOption.REPLACE_EXISTING,
            StandardCopyOption.ATOMIC_MOVE);
    }
    
    public static Aplicacion cargarEstado() 
            throws IOException, ClassNotFoundException {
        // Validar existencia
        if (!Files.exists(Paths.get(BACKUP_FILE))) {
            throw new FileNotFoundException("No existe backup");
        }
        
        // Deserializaci√≥n segura
        try (ObjectInputStream ois = new ObjectInputStream(
                new BufferedInputStream(
                    Files.newInputStream(Paths.get(BACKUP_FILE))))) {
            
            Object obj = ois.readObject();
            if (!(obj instanceof Aplicacion)) {
                throw new InvalidObjectException("Tipo incorrecto");
            }
            
            return (Aplicacion) obj;
        }
    }
}
```

---

## üìå Puntos Clave
1. **Serializable** es una interfaz marcadora
2. **serialVersionUID** evita problemas de versi√≥n
3. **transient** excluye campos de la serializaci√≥n
4. **writeObject/readObject** para control personalizado
5. **Externalizable** para serializaci√≥n manual

---
# CAP√çTULO 21: INTRODUCCI√ìN A NIO (NEW I/O) EN JAVA

## üöÄ Introducci√≥n a NIO
NIO (New Input/Output) es una API moderna que supera las limitaciones del I/O tradicional, ofreciendo:
- **Mayor rendimiento**: Uso de buffers y canales
- **Operaciones no bloqueantes**
- **API m√°s expresiva** para manejo de archivos

```java
import java.nio.file.*;
import java.io.IOException;

// Ejemplo b√°sico de lectura
String contenido = Files.readString(Paths.get("archivo.txt"));
```

---

## 21.1 Comparaci√≥n IO vs NIO

| Caracter√≠stica       | Java IO           | Java NIO          |
|----------------------|-------------------|-------------------|
| **Modelo**           | Stream-oriented   | Buffer-oriented   |
| **Bloqueo**          | Siempre bloqueante| Puede ser no-bloqueante |
| **Operaciones**      | Secuenciales      | Aleatorias        |
| **Componentes**      | Streams           | Canales y Buffers |
| **Manejo archivos**  | B√°sico            | Avanzado (NIO.2)  |

---

## 21.2 Clases Fundamentales de NIO.2

### Path - Representaci√≥n de rutas
```java
Path rutaAbsoluta = Paths.get("/home/usuario/datos.txt");
Path rutaRelativa = Paths.get("docs", "config", "app.properties");

// M√©todos √∫tiles
Path padre = rutaAbsoluta.getParent();
String nombreArchivo = rutaAbsoluta.getFileName().toString();
Path normalizado = rutaRelativa.normalize(); // Elimina . y ..
```

### Files - Operaciones con archivos
```java
// Creaci√≥n
Files.createDirectories(Paths.get("nueva/carpeta/subcarpeta"));

// Verificaci√≥n
boolean existe = Files.exists(ruta);
boolean esLegible = Files.isReadable(ruta);
long tama√±o = Files.size(ruta);

// Eliminaci√≥n
Files.deleteIfExists(ruta);
```

---

## 21.3 Lectura y Escritura Eficiente

### Lectura de Archivos
```java
// Leer todo el contenido como String (Java 11+)
String contenido = Files.readString(ruta);

// Leer todas las l√≠neas
List<String> lineas = Files.readAllLines(ruta);

// Lectura eficiente para archivos grandes
try (Stream<String> stream = Files.lines(ruta)) {
    stream.filter(line -> !line.isEmpty())
          .forEach(System.out::println);
}
```

### Escritura de Archivos
```java
// Escribir String completo
Files.writeString(ruta, "Contenido del archivo");

// A√±adir a archivo existente
Files.writeString(ruta, "\nNueva l√≠nea", StandardOpenOption.APPEND);

// Escribir colecci√≥n de l√≠neas
List<String> datos = Arrays.asList("L√≠nea 1", "L√≠nea 2");
Files.write(ruta, datos, StandardCharsets.UTF_8);
```

---

## 21.4 Operaciones Avanzadas

### Copia de Archivos
```java
Path origen = Paths.get("origen.txt");
Path destino = Paths.get("backup/origen.txt");

Files.copy(origen, destino, 
    StandardCopyOption.REPLACE_EXISTING,
    StandardCopyOption.COPY_ATTRIBUTES);
```

### Movimiento/Renombrado
```java
Files.move(Paths.get("viejo.txt"), Paths.get("nuevo.txt"),
    StandardCopyOption.REPLACE_EXISTING);
```

### Comparaci√≥n de Archivos
```java
boolean mismoArchivo = Files.isSameFile(ruta1, ruta2);
long diferencia = Files.mismatch(ruta1, ruta2); // Devuelve -1 si son iguales
```

---

## 21.5 Manejo de Metadatos

### Atributos B√°sicos
```java
BasicFileAttributes attrs = Files.readAttributes(ruta, BasicFileAttributes.class);

System.out.println("Tama√±o: " + attrs.size());
System.out.println("Creado: " + attrs.creationTime());
System.out.println("Es directorio: " + attrs.isDirectory());
```

### Atributos POSIX (Linux/Unix)
```java
PosixFileAttributes posixAttrs = Files.readAttributes(ruta, PosixFileAttributes.class);
System.out.println("Permisos: " + posixAttrs.permissions());
System.out.println("Propietario: " + posixAttrs.owner());
```

### Modificaci√≥n de Permisos
```java
Files.setPosixFilePermissions(ruta, 
    PosixFilePermissions.fromString("rw-r-----"));
```

---

## 21.6 Buenas Pr√°cticas üõ°Ô∏è

### 1. Manejo de Rutas Multiplataforma
```java
// ‚ùå Fr√°gil
Path rutaMala = Paths.get("C:\\Users\\doc.txt");

// ‚úÖ Correcto
Path rutaBuena = Paths.get(System.getProperty("user.home"), "doc.txt");
```

### 2. Procesamiento de Archivos Grandes
```java
try (BufferedReader br = Files.newBufferedReader(ruta)) {
    String linea;
    while ((linea = br.readLine()) != null) {
        procesarLinea(linea);
    }
}
```

### 3. Manejo Seguro de Temporales
```java
Path tempFile = Files.createTempFile("prefijo_", ".tmp");
try {
    // Usar archivo temporal
} finally {
    Files.deleteIfExists(tempFile);
}
```

### 4. Walk File Tree
```java
Files.walkFileTree(Paths.get("/ruta"), new SimpleFileVisitor<>() {
    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
        System.out.println("Archivo: " + file);
        return FileVisitResult.CONTINUE;
    }
    
    @Override
    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
        System.out.println("Directorio: " + dir);
        return FileVisitResult.CONTINUE;
    }
});
```

---

## üîÑ Ejemplo Integrado: Buscador de Archivos
```java
public class BuscadorArchivos {
    public static List<Path> buscar(String directorio, String extension) throws IOException {
        List<Path> resultados = new ArrayList<>();
        
        Files.walkFileTree(Paths.get(directorio), new SimpleFileVisitor<>() {
            @Override
            public FileVisitResult visitFile(Path archivo, BasicFileAttributes attrs) {
                if (archivo.toString().endsWith(extension)) {
                    resultados.add(archivo);
                }
                return FileVisitResult.CONTINUE;
            }
            
            @Override
            public FileVisitResult visitFileFailed(Path file, IOException exc) {
                System.err.println("Error accediendo a: " + file + ": " + exc);
                return FileVisitResult.CONTINUE;
            }
        });
        
        return resultados;
    }
    
    public static void main(String[] args) throws IOException {
        List<Path> archivosJava = buscar("src/main/java", ".java");
        archivosJava.forEach(System.out::println);
    }
}
```

---

## üìå Puntos Clave
1. **Path** representa rutas de forma multiplataforma
2. **Files** ofrece operaciones avanzadas con archivos
3. **Stream API** para procesamiento eficiente
4. **WalkFileTree** para recorrer directorios recursivamente
5. **Atributos** para acceso a metadatos del sistema de archivos









